<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开源协议与开源软件</title>
      <link href="/OpenSource/"/>
      <url>/OpenSource/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是开源软件"><a class="header-anchor" href="#什么是开源软件"># </a>什么是开源软件</h2><blockquote><p>开源软件就是把软件程序与源代码文件一起打包提供给用户，用户既可以不受限制地使用该软件的全部功能，也可以根据自己的需求修改源代码，甚至编制成衍生产品再次发布出去。</p></blockquote><p>  用户具有使用自由、修改自由、重新发布自由和创建衍生品自由，这正好符合了黑客和极客对自由的追求，因此开源软件在国内外都有着很高的人气，大家聚集在开源社区，共同推动开源软件的进步。支持开源软件的企业不单出是为了利益，而是相互扶持，共同努力服务好更多的用户。</p><a id="more"></a><blockquote><p>开源软件的优点</p></blockquote><table><thead><tr><th style="text-align:center">四大优点</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">低风险</td><td>使用闭源软件无疑是把命运交给他人，一旦封闭的源代码没有人来维护，你将进退维谷；而且相较于商业软件公司，开源社区很少存在倒闭的问题。</td></tr><tr><td style="text-align:center">高品质</td><td>相较于闭源软件产品，开源项目通常是由开源社区来研发及维护的，参与编写、维护、测试的用户量众多，一般的 bug 还没有等爆发就已经被修补。</td></tr><tr><td style="text-align:center">低成本</td><td>开源工作者都是在幕后默默且无偿地付出劳动成果，为美好的世界贡献一份力量，因此使用开源社区推动的软件项目可以节省大量的人力、物力和财力。</td></tr><tr><td style="text-align:center">更透明</td><td>没有哪个笨蛋会把木马、后门等放到开放的源代码中，这样无疑是把自己的罪行暴露在阳光之下。</td></tr></tbody></table><h3 id="典型的开源软件"><a class="header-anchor" href="#典型的开源软件"># </a>典型的开源软件</h3><table><thead><tr><th>软件</th><th>说明</th></tr></thead><tbody><tr><td>Linux</td><td>Linux 是一款开源的操作系统，它的内核由多名极客共同维护。Linux 是开源软件的经典之作、代表之作、巅峰之作。</td></tr><tr><td>Apache</td><td>世界使用排名第一的 Web 服务器软件。</td></tr><tr><td><a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">MySQL</a></td><td>世界上最流行的关系型数据库，适合中小型网站。</td></tr><tr><td>Firefox</td><td>火狐浏览器。在 Chrome 推出之前，Firefox 几乎是最快速的浏览器，直到现在也是 Web 开发人员的调试利器。</td></tr><tr><td>OpenOffice</td><td>套跨平台的办公软件套件，类似 Microsoft Office。</td></tr><tr><td><a href="http://c.biancheng.net/gcc/" target="_blank" rel="noopener">GCC</a></td><td><a href="http://c.biancheng.net/c/" target="_blank" rel="noopener">C语言</a>/<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a>编译器。</td></tr><tr><td><a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java</a>、<a href="http://c.biancheng.net/php/" target="_blank" rel="noopener">PHP</a>、<a href="http://c.biancheng.net/python/" target="_blank" rel="noopener">Python</a></td><td>开源的编程语言。</td></tr></tbody></table><h3 id="开源社区"><a class="header-anchor" href="#开源社区"># </a>开源社区</h3><p>国内外开源社区推荐：<a href="https://www.oschina.net/" target="_blank" rel="noopener">开源中国</a>、<a href="http://www.chinaunix.net/" target="_blank" rel="noopener">ChinaUnix</a>、<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>、<a href="http://www.apache.org/" target="_blank" rel="noopener">Apache</a>、<a href="https://sourceforge.net/" target="_blank" rel="noopener">SourceForge</a>、</p><p>开源社区以国外为主，国内开源社区由于资金、人才、气氛等问题一直不太稳定，最后附上一张开源社区汇总图。</p><p><img src="http://c.biancheng.net/uploads/allimg/190328/1-1Z32QA10W42.jpg" alt></p><h2 id="开源协议"><a class="header-anchor" href="#开源协议"># </a>开源协议</h2><blockquote><p>开源协议规定了你在使用开源软件时的权利和责任，也就是规定了你可以做什么，不可以做什么。</p></blockquote><p>  开源软件在追求“自由”的同时，不能牺牲程序员的利益，否则将会影响程序员的创造激情，因此世界上现在有 60 多种被开源促进组织（Open Source Initiative）认可的开源许可协议来保证开源工作者的权益。下面列举了常见的开源协议</p><h3 id="1-gnu-gpl-gnu-general-public-license-gnu通用公共许可证"><a class="header-anchor" href="#1-gnu-gpl-gnu-general-public-license-gnu通用公共许可证"># </a>1、 GNU GPL（GNU General Public License，GNU通用公共许可证）</h3><p>  只要软件中包含了遵循 GPL 协议的产品或代码，该软件就必须也遵循 GPL 许可协议，也就是必须开源免费，不能闭源收费，因此这个协议并不适合商用软件。遵循 GPL 协议的开源软件数量极其庞大，包括 Linux系统在内的大多数的开源软件都是基于这个协议的。</p><table><thead><tr><th>GPL开源的主要特点</th><th>说明</th></tr></thead><tbody><tr><td>复制自由</td><td>允许把软件复制到任何人的电脑中，并且不限制复制的数量。</td></tr><tr><td>传播自由</td><td>允许软件以各种形式进行传播。</td></tr><tr><td>收费传播</td><td>允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的；因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。</td></tr><tr><td>修改自由</td><td>允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可协议授权。</td></tr></tbody></table><h3 id="2-bsd-berkeley-software-distribution-伯克利软件发布版-协议"><a class="header-anchor" href="#2-bsd-berkeley-software-distribution-伯克利软件发布版-协议"># </a>2、BSD（Berkeley Software Distribution，伯克利软件发布版）协议</h3><p>  BSD 协议基本上允许用户“为所欲为”，用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面三个条件：</p><ul><li>如果再发布的软件中包含源代码，则源代码必须继续遵循 BSD 许可协议。</li><li>如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了 BSD 协议。</li><li>不允许用原始软件的名字、作者名字或机构名称进行市场推广。</li></ul><p>  BSD 对商业比较友好，很多公司在选用开源产品的时候都首选 BSD 协议，因为可以完全控制这些第三方的代码，甚至在必要的时候可以修改或者二次开发。</p><h3 id="3-apache-许可证版本-apache-license-version-协议"><a class="header-anchor" href="#3-apache-许可证版本-apache-license-version-协议"># </a>3、Apache 许可证版本（Apache License Version）协议</h3><p>  Apache 和 BSD 类似，都适用于商业软件。Apache 协议在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由。<br>  现在热门的 Hadoop、Apache HTTP Server、MongoDB 等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的四个条件：</p><ul><li>该软件及其衍生品必须继续使用 Apache 许可协议。</li><li>如果修改了程序源代码，需要在文档中进行声明。</li><li>若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。</li><li>如果再发布的软件中有声明文件，则需在此文件中标注 Apache 许可协议及其他许可协议。</li></ul><h4 id="4-mit-massachusetts-institute-of-technology-协议"><a class="header-anchor" href="#4-mit-massachusetts-institute-of-technology-协议"># </a>4、 MIT（Massachusetts Institute of Technology）协议</h4><p>  目前限制最少的开源许可协议之一（比 BSD 和 Apache 的限制都少），只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。</p><p>  使用 MIT 协议的软件有 PuTTY、X Window System、Ruby on Rails、Lua 5.0 onwards、Mono 等。</p><h3 id="5-gun-lgpl-gnu-lesser-general-public-license-gnu-宽通用公共许可证"><a class="header-anchor" href="#5-gun-lgpl-gnu-lesser-general-public-license-gnu-宽通用公共许可证"># </a>5、GUN LGPL（GNU Lesser General Public License，GNU 宽通用公共许可证）</h3><p>  LGPL 是 GPL 的一个衍生版本，也被称为 GPL V2，该协议主要是为类库设计的开源协议。</p><p>  LGPL 允许商业软件通过类库引用（link）的方式使用 LGPL 类库，而不需要开源商业软件的代码。这使得采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售。</p><p>  但是如果修改 LGPL 协议的代码或者衍生品，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以 LGPL 协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p><h3 id="6-文档的cc协议"><a class="header-anchor" href="#6-文档的cc协议"># </a>6、文档的CC协议</h3><p>  CC协议（A Creative Commons license）的中文叫做知识共享许可协议，是允许他人分发作品的公共版权许可之一。2002年12月16日，美国非盈利公司Creative Commons首次发布了CC协议。在经历了三个不同版本之后，CC 4.0于2013年11月25日发布。自此之后，CC 4.0被鼓励在全球范围内适用。</p><p>  创作共享协议允许作者选择不同的授权条款和根据不同国家的著作权法制定的版权协议，版权持有人可以指定以下的条件：</p><ul><li><p>姓名标示（by）：您可以自由复制、散布、展示及演出本作品；您必须按照莞作者或授权人所指定的方式，保留其姓名标示。</p></li><li><p>非商业性（nc）：您可以自由复制、散布、展示及演出本作品；您不得为商业目的而使用本作品。</p></li><li><p>禁止改作（nd）：你可以自由复制、散布、展示及演出本作品；您不得改变、转变或改作本作品。</p></li><li><p>相同方式分享（sa）：你可以自由复制、散布、展示及演出本作品；若您改变、转变或改作本作品，仅在遵守与本著作相同的授权条款下，您才能散布由本作品产生的衍生作品。</p></li></ul><h2 id="如何选择开源协议"><a class="header-anchor" href="#如何选择开源协议"># </a>如何选择开源协议</h2><p>  世界上的开源协议有上百种<a href="http://www.gnu.org/licenses/license-list.html" target="_blank" rel="noopener">点击查看</a>，乌克兰程序员 Paul Bagwell 画了一张分析图，说明应该怎么选择开源协议，</p><blockquote><p>图片来自于阮一峰博客：<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener">如何选择开源协议</a></p></blockquote><p><img src="http://www.ruanyifeng.com/blogimg/asset/201105/free_software_licenses.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关常识 </category>
          
          <category> 软件常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源协议 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 文件系统</title>
      <link href="/note/server/linux/LinuxFileSystem/"/>
      <url>/note/server/linux/LinuxFileSystem/</url>
      
        <content type="html"><![CDATA[<h2 id="linux-一切皆文件"><a class="header-anchor" href="#linux-一切皆文件"># </a>Linux 一切皆文件</h2><p>  Linux中所有内容都是以文件的形式保存和管理的，即一切皆文件，普通文件是文件，目录（Windows 下称为文件夹）是文件，硬件设备（键盘、监视器、硬盘、打印机）是文件，就连套接字（<a href="http://c.biancheng.net/socket/" target="_blank" rel="noopener">socket</a>)、网络通信等资源也都是文件。</p><p>Linux系统中，文件具体可分为以下几种类型：</p><ol><li>普通文件<ul><li>类似 mp4、pdf、html 这样，可直接拿来使用的文件都属于普通文件，Linux 用户根据访问权限的不同可以对这些文件进行查看、删除以及更改操作。</li></ul></li><li>目录文件<ul><li>Linux 系统中，目录文件包含了此目录中各个文件的文件名以及指向这些文件的指针，打开目录等同于打开目录文件，只要你有权限，可以随意访问目录中的任何文件。（目录文件的访问权限，同普通文件的执行权限，是一个意思。）</li></ul></li><li>字符设备文件和块设备文件<ul><li>Linux 系统中的所有设备，要么是块设备文件，要么是字符设备文件。这些文件通常隐藏在 /dev/ 目录下，当进行设备读取或外设交互时才会被使用。</li><li>例如，磁盘光驱属于块设备文件，串口设备则属于字符设备文件。</li></ul></li><li>套接字文件(<a href="http://c.biancheng.net/socket/" target="_blank" rel="noopener">socket</a>)<ul><li>套接字文件一般隐藏在 /var/run/ 目录下，用于进程间的网络通信。</li></ul></li><li>符号连接文件(symbolic link)<ul><li>类似与 Windows 中的快捷方式，是指向另一文件的简介指针（也就是软链接）。</li></ul></li><li>管道文件(pipe)<ul><li>主要用于进程间通信。例如，使用 mkfifo 命令创建一个 FIFO 文件，与此同时，启用进程 A 从 FIFO文件读数据，启用进程 B 从 FIFO文件中写数据，随写随读。</li></ul></li></ol><a id="more"></a><h3 id="一切皆文件-的利弊"><a class="header-anchor" href="#一切皆文件-的利弊"># </a>“一切皆文件”的利弊</h3><p>  和 Windows 系统不同，Linux 系统没有 C 盘、D 盘、E 盘那么多的盘符，只有一个根目录（/），所有的文件（资源）都存储在以根目录（/）为树根的树形目录结构中。</p><p>  这样做最明显的好处是，开发者仅需要使用一套 API 和开发工具即可调取 Linux 系统中绝大部分的资源。举个简单的例子，Linux 中几乎所有读（读文件，读系统状态，读 socket，读 PIPE）的操作都可以用 read 函数来进行；几乎所有更改（更改文件，更改系统参数，写 socket，写 PIPE）的操作都可以用 write 函数来进行。</p><p>  不利之处在于，使用任何硬件设备都必须与根目录下某一目录执行挂载操作，否则无法使用。我们知道，本身 Linux 具有一个以根目录为树根的文件目录结构，每个设备也同样如此，它们是相互独立的。如果我们想通过 Linux 上的根目录找到设备文件的目录结构，就必须将这两个文件系统目录合二为一，这就是挂载的真正含义。</p><h2 id="linux-目录的层次结构"><a class="header-anchor" href="#linux-目录的层次结构"># </a>Linux 目录的层次结构</h2><p>  Linux操作系统中，所有的文件和目录都被组织成以一个根节点“/”开始的倒置的树状结构：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/003vPl7Rty6E8kZRlAEdc690.jpg" alt="Linux目录结构"></p><p>  目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由“/”来分隔。如 cat 的完整路径是 /home/cat。</p><p>  在文件系统中，有两个特殊的目录，一个是用户所在的工作目录，即当前目录，可用一个点“.”表示；另一个是当前目录的上一层目录，也叫父目录，用两个点“…”表示。</p><p>  如果一个目录或文件名以一个点 . 开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)。即以默认方式查找时，不显示该目录或文件。</p><hr><p>  由于 Linux 系统免费开源，使得 Linux 发行版本有很多，利用 Linux 开发产品的团队也有很多，如果任由每个人都按照自己的想法来配置 Linux 系统文件目录，后期可能会产生诸多的管理问题。为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准。</p><h3 id="linux文件目录结构"><a class="header-anchor" href="#linux文件目录结构"># </a>Linux文件目录结构</h3><p>  为了方便管理和维护，Linux 系统采用了文件系统层次标准，也称为 FHS 标准<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，它规定了根目录下各个目录应该存在哪些类型的文件（或子目录）。</p><h4 id="linux-根目录"><a class="header-anchor" href="#linux-根目录"># </a>Linux 根目录（/）</h4><p>  FHS 认为，Linux 系统的根目录（/）最为重要（没有之一），其原因有以下 2 点：</p><ol><li>所有目录都是由根目录衍生出来的；</li><li>根目录与系统的开机、修复、还原密切相关；</li></ol><p>  因此，根目录必须包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件，如下表所示</p><table><thead><tr><th style="text-align:center">一级目录</th><th>功能（作用）</th></tr></thead><tbody><tr><td style="text-align:center">/bin/</td><td>存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行</td></tr><tr><td style="text-align:center">/boot/</td><td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</td></tr><tr><td style="text-align:center">/dev/</td><td>设备文件保存位置</td></tr><tr><td style="text-align:center">/etc/</td><td>配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td></tr><tr><td style="text-align:center">/home/</td><td>普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 /home/liming</td></tr><tr><td style="text-align:center">/lib/</td><td>系统调用的函数库保存位置</td></tr><tr><td style="text-align:center">/media/</td><td>挂载目录。系统建议用来挂载媒体设备，如软盘和光盘</td></tr><tr><td style="text-align:center">/mnt/</td><td>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</td></tr><tr><td style="text-align:center">/misc/</td><td>挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，笔者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 /mnt/ 下建立不同目录挂载不同设备的习惯，如 /mnt/cdrom/ 挂载光盘、/mnt/usb/ 挂载 U 盘，都是可以的</td></tr><tr><td style="text-align:center">/opt/</td><td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 /usr/local/ 目录中，也就是说，/usr/local/ 目录也可以用来安装软件</td></tr><tr><td style="text-align:center">/root/</td><td>root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下</td></tr><tr><td style="text-align:center">/sbin/</td><td>保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</td></tr><tr><td style="text-align:center">/srv/</td><td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td></tr><tr><td style="text-align:center">/tmp/</td><td>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td></tr></tbody></table><p>  FHS 针对根目录中包含的子目录仅限于上表，但除此之外，Linux 系统根目录下通常还包含以下表 中的几个一级目录。</p><table><thead><tr><th>一级目录</th><th>功能（作用）</th></tr></thead><tbody><tr><td>/lost+found/</td><td>当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，/lost+found 就是根分区的备份恢复目录，/boot/lost+found 就是 /boot 分区的备份恢复目录</td></tr><tr><td>/proc/</td><td>虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如 /proc/cpuinfo 是保存 CPU 信息的，/proc/devices 是保存设备驱动的列表的，/proc/filesystems 是保存文件系统列表的，/proc/net 是保存网络协议信息的…</td></tr><tr><td>/sys/</td><td>虚拟文件系统。和 /proc/ 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td></tr></tbody></table><h4 id="linux-usr目录"><a class="header-anchor" href="#linux-usr目录"># </a>Linux /usr目录</h4><p>  usr（注意不是 user），全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 /usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。<br>  Linux 系统中，所有系统默认的软件都存储在 /usr 目录下，/usr 目录类似 Windows 系统中 C:\Windows\ + C:\Program files\ 两个目录的综合体。FHS 建议，/usr 目录应具备以下子目录。</p><table><thead><tr><th>子目录</th><th>功能（作用）</th></tr></thead><tbody><tr><td>/usr/bin/</td><td>存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td></tr><tr><td>/usr/sbin/</td><td>存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。</td></tr><tr><td>/usr/lib/</td><td>应用程序调用的函数库保存位置</td></tr><tr><td>/usr/XllR6/</td><td>图形界面系统保存位置</td></tr><tr><td>/usr/local/</td><td>手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置</td></tr><tr><td>/usr/share/</td><td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td></tr><tr><td>/usr/src/</td><td>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 /usr/local/src/ 目录中，把内核源码保存到 /usr/src/linux/ 目录中</td></tr><tr><td>/usr/include</td><td>C/C++ 等编程语言头文件的放置目录</td></tr></tbody></table><h4 id="linux-var-目录"><a class="header-anchor" href="#linux-var-目录"># </a>Linux /var 目录</h4><p>  /var 目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。通常，此目录下建议包含如下所示的这些子目录。</p><table><thead><tr><th>/var子目录</th><th>功能（作用）</th></tr></thead><tbody><tr><td>/var/lib/</td><td>程序运行中需要调用或改变的数据保存位置。如 <a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">MySQL</a> 的数据库保存在 /var/lib/mysql/ 目录中</td></tr><tr><td>/var/log/</td><td>登陆文件放置的目录，其中所包含比较重要的文件如 /var/log/messages, /var/log/wtmp 等。</td></tr><tr><td>/var/run/</td><td>一些服务和程序运行后，它们的 PID（进程 ID）保存位置</td></tr><tr><td>/var/spool/</td><td>里面主要都是一些临时存放，随时会被用户所调用的数据，例如 /var/spool/mail/ 存放新收到的邮件，/var/spool/cron/ 存放系统定时任务。</td></tr><tr><td>/var/www/</td><td>RPM 包安装的 Apache 的网页主目录</td></tr><tr><td>/var/nis和/var/yp</td><td>NIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录</td></tr><tr><td>/var/tmp</td><td>一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除</td></tr></tbody></table><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>FHS（Filesystem Hierarchy Standard），文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（/usr 和 /var）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。 <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 服务器端 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统启动过程</title>
      <link href="/note/server/linux/LinuxBootProcess/"/>
      <url>/note/server/linux/LinuxBootProcess/</url>
      
        <content type="html"><![CDATA[<p>  Linux系统的启动，从计算机开机通电自检开始，一直到登陆系统，总共经历如下几个过程：</p><ol><li>服务器加电，加载 BIOS 信息，BIOS 进行系统检测。依照 BIOS 设定，找到第一个可以启动的设备（一般是硬盘）；</li><li>读取第一个启动设备的 MBR (主引导记录），加载 MBR 中的 Boot Loader（启动引导程序，最为常见的是 GRUB）。</li><li>依据 Boot Loader 的设置加载内核，内核会再进行一遍系统检测。系统一般会采用内核检测硬件的信息，而不一定采用 Bios 的自检信息。内核在检测硬件的同时，还会通过加载动态模块的形式加载硬件的驱动。</li><li>内核启动系统的第一个进程，也就是 /sbin/init。</li><li>由 /sbin/init 进程调用/etc目录下的init程序 ，来配置计算机的初始环境、确定系统的默认运行级别。</li><li>确定默认运行级别后，调用 /etc/init/rc.conf 配置文件初始化系统，然后执行 /etc/rc.d/rc.local 中的程序。</li><li>如果是终端界面启动，就可以看到登录界面了。如果是图形界面启动，就会调用相应的 X Window 接口。</li></ol><a id="more"></a><hr><p>  总的来说Linux启动过程大致分为五个过程:<code>BIOS启动-&gt;内核引导过程-&gt;运行init(初始化配置文件)-&gt;系统初始化-&gt;建立终端或载入用户登陆系统</code></p><h2 id="硬件启动与引导"><a class="header-anchor" href="#硬件启动与引导"># </a>硬件启动与引导</h2><h3 id="biso启动"><a class="header-anchor" href="#biso启动"># </a>BISO启动</h3><p>  BIOS 全称 Basic Input/Output System，中文可译为基本输入/输出系统。它是固化在主板上一个 ROM（只读存储器）芯片上的程序，主要保存计算机的基本输入/输出信息、系统设置信息、开机自检程和系统自启动程序，用来为 计算机提供最底层和最直接的硬件设置与控制。BIOS 的初始化主要完成以下 几 项工作：</p><ol><li>当 BIOS 一启动，就会检查计算机硬件和外围设备（例如 CPU、内存、风扇灯），整个自检过程也被称为 POST（Power On Self Test）自检。</li><li>如果自检没有问题，BIOS 开始对硬件进行初始化，并规定当前可启动设备的先后顺序，选择由那个设备来开机。</li><li>选择好开启设备后，就会从该设备的 MBR（主引导目录）中读取 Boot Loader（启动引导程序）并执行。启动引导程序用于引导操作系统启动，Linux系统中默认使用的启动引导程序是 GRUB。</li><li>当 MBR 被加载到 RAM 之后，BIOS 就会将控制权交给 MBR，进入系统引导的第二阶段。</li></ol><h3 id="读取mbr"><a class="header-anchor" href="#读取mbr"># </a>读取MBR</h3><p>  MBR 也就是主引导记录，最主要的功能就是存储启动引导程序。MBR位于硬盘的 0 磁道、0 柱面、1 扇区中，主要记录了启动引导程序和磁盘的分区表。MBR 共占用了一个扇区，也就是 512 Byte。其中 446 Byte 安装了启动引导程序，其后 64 Byte 描述分区表，最后的 2 Byte 是结束标记。</p><blockquote><p>MBR结构图：</p></blockquote><p><img src="/../assets/Linux/0/MDR%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="MDR结构图"></p><p>  之所以每块硬盘只能划分四个分区，原因就是在 MBR 中描述分区表的空间只有 64 Byte。其中每个分区必须占用 16 Byte，那么 64 Byte 就只能划分 4 个主分区。每个分区的 16 字节的规划如表 ：</p><table><thead><tr><th style="text-align:center">存储字节</th><th style="text-align:center">数据内容及含义</th></tr></thead><tbody><tr><td style="text-align:center">第 1 字节</td><td style="text-align:center">引导标志</td></tr><tr><td style="text-align:center">第 2 字节</td><td style="text-align:center">本分区的起始磁道号</td></tr><tr><td style="text-align:center">第 3 字节</td><td style="text-align:center">本分区的起始扇区号</td></tr><tr><td style="text-align:center">第 4 字节</td><td style="text-align:center">本分区的起始柱面号</td></tr><tr><td style="text-align:center">第 5 字节</td><td style="text-align:center">分区类型，可以识别主分区和扩展分区</td></tr><tr><td style="text-align:center">第 6 字节</td><td style="text-align:center">本分区的结束磁道号</td></tr><tr><td style="text-align:center">第 7 字节</td><td style="text-align:center">本分区的结束扇区号</td></tr><tr><td style="text-align:center">第 8 字节</td><td style="text-align:center">本分区的结束柱面号</td></tr><tr><td style="text-align:center">第 9~12 字节</td><td style="text-align:center">本分区之前已经占用的扇区数</td></tr><tr><td style="text-align:center">第 13~16 字节</td><td style="text-align:center">本分区的总扇区数</td></tr></tbody></table><h4 id="启动引导程序的作用"><a class="header-anchor" href="#启动引导程序的作用"># </a>启动引导程序的作用</h4><p>  BIOS 的作用就是自检，然后从 MBR 中读取出启动引导程序，所以，启动引导程序最主要的作用就是加载操作系统的内核。由于每种操作系统的文件格式不同，因此每种操作系统的启动引导程序也不一样。不同的操作系统只有使用自己的启动引导程序才能加载自己的内核。如果服务器中安装了多个操作系统，而 MBR 只有一 个，那么明显是不够用的。</p><p>  然而每块硬盘只能有一个 MBR 是不能更改的，所以不可能増加 MBR 的数量。系统只能在每个文件系统（可以看成分区）中单独划分出一个扇区，称作引导扇区（Boot Sector)。每个分区的引导扇区中也能安装启动引导程序，也就是说，在 MBR 和每个单独分区的引导扇区中都可以安装启动引导程序。这样多个操作系统才能安装在同一台服务器中（每个操作系统要安装在不同的分区中），而且每个操作系统都是可以启动的。</p><p>  但是BIOS 只能找到 MBR 中的启动引导程序，而找不到在分区的引导扇区中的启动引导程序。如果要想完成多系统启动，那么就要増加启动引导程序的功能，让安装到 MBR 中的启动引导程序（GRUB）来调用在分区的引导扇区中的其他启动引导程序。</p><p>因此，启动引导程序拥有以下功能：</p><ol><li>加载操作系统的内核。这是启动引导程序最主要的功能。</li><li>拥有一个可以让用户选择的菜单，来选择到底启动哪个系统。大家如果在服务器上安装过双 Windows 系统，就应该见过类似的选择菜单，不过这个选择菜单是由 Windows 的启动引导程序提供的，而不是 GRUB。</li><li>可以调用其他的启动引导程序，这是多系统启动的关键。不过需要注意的是，Windows 的启动引导程序不能调用 Linux的启动引导程序，所以我们一般建议先安装 Windows，后安装 Linux，是为了将 Linux 的启动引导程序安装到 MBR 中，覆盖 Windows 的启动引导程序。</li></ol><p>启动引导程序的作用示意图：</p><img src="/../assets/Linux/0/MBR的作用.jpg" alt="MBR的作用" style="zoom:125%;"><h2 id="linux内核模块加载"><a class="header-anchor" href="#linux内核模块加载"># </a>Linux内核模块加载</h2><p>  GRUB 加载了内核之后，内核首先会再进行二次系统的自检，而不一定使用 BIOS 检测的硬件信息。这时内核终于开始替代 BIOS 接管 Linux的启动过程了。</p><p>  内核再次系统自检后，就会开始动态加载每个硬件的模块，这个动态模块大家可以想象成硬件的驱动<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。Linux 的内核存放在 /boot 的启动目录中。</p><figure class="highlight bash"><figcaption><span>/boot目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#ls /boot/</span></span><br><span class="line">config-2.6.32-279.el6.i686 <span class="comment">#内核的配置文件，内核编译时选择的功能与模块</span></span><br><span class="line">efi <span class="comment">#可扩展固件接口，为英特尔为全新PC固件的体系结构、接口和服务提出的建议标准</span></span><br><span class="line">grub <span class="comment">#启动引导程GTUB的数据目录</span></span><br><span class="line">initramfe-2.6.32-279.el6.i686.img <span class="comment">#虚拟文件系统（CentOS 6.x 中用initramfs替代了initrd,但功能是一样的）</span></span><br><span class="line">lost+found <span class="comment"># boot分区的备份目录</span></span><br><span class="line">symvers-2_6.32-279.el6.i686.gz <span class="comment">#模块符号信息</span></span><br><span class="line">System.map-2.6.32-279.el6.i686 <span class="comment">#内核功能和内存地址的对应列表</span></span><br><span class="line">vmlinuz-2.6.32-279.el6.i686 <span class="comment">#用于启动的Linux内核。这个文件是一个压缩的内核镜像</span></span><br></pre></td></tr></table></figure><p>  Linux 为了保证了内核不会过大，会把不重要的功能编译成内核模块，在需要时再调用。在多数 Linux 中，都会把硬件的驱动程序编译为模块， 这些模块保存在 /lib/modules 目录中。常见的 USB、SATA 和 SCSI 等硬盘设备的驱动，还有一些特殊的文件系统（如 LVM、RAID 等）的驱动，都是以模块的方式来保存的。</p><p>  如果 Linux 安装在 IDE 硬盘之上，并且采用的是默认的 ext3/4 文件系统，那么内核启动后加载根分区和模块的加载都没有什么问题。如果要将 Linux 安装在 SCSI 硬盘之上，或者采用的是 LVM 文件系统，那么内核（内核载入内存是启动引导程序 GRUB 调用的，并不存在硬盘驱动不识别的问题）在加载根目录之前是需要加载 SCSI 硬盘或 LVM 文件系统的驱动的。而SCSI 硬盘和 LVM 文件系统的驱动都放在硬盘的 /lib/modules 目录中，内核没有办法识别 ，因此Linux 采用了 initramfs 这个虚拟文件系统来处理这个问题。</p><h3 id="initramfe虚拟文件系统"><a class="header-anchor" href="#initramfe虚拟文件系统"># </a>initramfe虚拟文件系统</h3><p>  CentOS 6.x 中使用 initramfs 虚拟文件系统取代了 CentOS 5.x 中的 initrd RAM Disk。它们的作用类似，可以通过 initramfs 虚拟文件系统在内存中模拟出一个根目录，然后在这个模拟根目录中加载 SCSI 等硬件的驱动，就可以加载真正的根目录了，之后才能调用 Linux 的第一个进程 /sbin/init。</p><p>Initramfs 虚拟文件系统主要有以下优点：</p><ul><li>initramfs 随着其中数据的増减自动増减容量。</li><li>在 initramfs 和页面缓存之间没有重复数据。</li><li>initramfs 重复利用了 Linux caching 的代码，因此几乎没有増加内核尺寸，而 caching 的代码已经经过良好测试，所以 initramfs 的代码质量也有保证。</li><li>不需要额外的文件系统驱动</li></ul><img src="/../assets/Linux/0/initramfe虚拟文件系统.jpg" alt="initramfe虚拟文件系统" style="zoom:125%;"><hr><p>  内核启动后，首先会去解析grub的配置文件<code>/boot/grub/grub.conf</code>，然后加载内核镜像到内存中，并将控制权转交给内核。而内核会立即初始化系统中各设备并做相关的配置工作，其中包括CPU、I/O、存储设备等。在内核加载完毕，系统开始运行第一个进程。</p><h2 id="第一个进程：init"><a class="header-anchor" href="#第一个进程：init"># </a>第一个进程：init</h2><p>  在内核加载完毕，并完成硬件检测与驱动程序加载后，此时主机硬件已经准备完毕，内核会主动呼叫第一个进程，也就是 /sbin/init，此配置文件最主要的功能就是准备软件执行的环境，包括系统的主机名、网络设定、语言、文件系统格式及其他服务的启动等。</p><p>  由于Linux内核的不断发展，各个发行版、各个版本的操作系统，采用的init程序配置系统完全不同。基本上是由 /sbin/init 进程来 <strong>配置计算机的初始环境</strong> 和 <strong>确定系统的默认运行级别</strong>。</p><p>  例如在 CentOS 6.x 系统中，由于用 Upstart 启动服务来替换以前的 init，所以在 /etc/inittab 配置文件中只能定义系统的默认运行级别，而其他的功能是靠 /etc/init/ 目录中的其他配置文件实现的。</p><blockquote><p>init程序的类型举例：</p><ul><li><p><strong>SysV:</strong> init, CentOS 5之前, 配置文件： <code>/etc/inittab。</code></p></li><li><p><strong>Upstart:</strong> init,CentOS 6, 配置文件：<code>/etc/inittab</code>,<code>/etc/init/*.conf。</code></p></li><li><p><strong>Systemd：</strong> systemd, CentOS 7,配置文件：<code>/usr/lib/systemd/system</code>、<code>/etc/systemd/system</code>。</p></li></ul><p>关于init系统的介绍，可以阅读以下文章：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html" target="_blank" rel="noopener">浅谈SysVinit</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/index.html" target="_blank" rel="noopener">浅谈Upstart</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html" target="_blank" rel="noopener">浅谈Systemd</a></li></ul></blockquote><h3 id="配置计算机的初始环境"><a class="header-anchor" href="#配置计算机的初始环境"># </a>配置计算机的初始环境</h3><p>  以centos 6采用的Upstart系统举例， /sbin/init 进程通过 /etc/init/rcS.conf 配置文件，分别找到 /etc/rc.d/rc.sysinit 配置文件和 /etc/inittab 配置文件，前者用于初始化系统，配置计算机的初始环境；后者用于确定系统的默认运行级别。用 Vim 查看 /etc/rc.d/rc.sysinit 配置文件，就会发现这个这个配置文件主要进行了以下几项工作：</p><ul><li>获得网络环境和主机类型；</li><li>测试设备：除了挂载内存设备 /proc 之外，还会主动侦测系统上是否具有 usb 设备，如果有，则会主动加载 usb 的驱动程序，并尝试挂载 usb 文件系统；</li><li>开机启动画面 Plymouth（代替了以往的 RHGB）；</li><li>判断是否启用 SELinux；</li><li>显示开机过程中的欢迎画面；</li><li>初始化硬件；</li><li>用户自定义模块的加载，用户可以在<code>/etc/sysconfig/modules/*.modules</code> 加入自订的模块，则此时会被加载到系统当中；</li><li>配置内核的参数，系统会主动去读取<code>/etc/sysctl.conf</code>这个文件的配置参数，使内核的功能成为我们想要的样子。</li><li>设置主机名。</li><li>同步存储器。</li><li>设备映射器及相关的初始化。</li><li>初始化软件磁盘阵列 (RAID)。</li><li>初始化 LVM 的文件系统功能。</li><li>检验磁盘文件系统 (fsck)。</li><li>设置磁盘配额 (quota)。</li><li>重新以可读写模式挂载系统磁盘。</li><li>更新 quota (非必要)。</li><li>启动系统虚拟随机数生成器。</li><li>配置机器（非必要）。</li><li>清除开机过程中的临时文件。</li><li>创建 ICE 目录。</li><li>启动交换分区（swap）。</li><li>将开机信息写入<code>/var/log/dmesg</code> 文件中。</li></ul><p>  <code>/etc/rc.d/rc.sysinit</code>配置文件已经将基本的系统配置数据都写好了，我们可以查询 <code>/var/log/dmesg</code>文件或使用 dmesg 命令查看系统在启动时到底发生了什么。当然，我们也可以通过这个命令来看看 Linux 服务器的硬件信息。</p><h3 id="配置运行级别"><a class="header-anchor" href="#配置运行级别"># </a>配置运行级别</h3><p>  在 CentOS 6.x 中，/etc/inittab 配置文件只能用来设置系统的默认运行级别。而在systemd 系统中，采用目标（target）替代了运行级别的概念，这里展示了Sysvinit 运行级别和 systemd 目标的对应表。</p><table><thead><tr><th style="text-align:center">Sysvinit 运行级别</th><th style="text-align:center">Systemd 目标</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">runlevel0.target, poweroff.target</td><td style="text-align:center">关闭系统。</td></tr><tr><td style="text-align:center">1, s, single</td><td style="text-align:center">runlevel1.target, rescue.target</td><td style="text-align:center">单用户模式。可以想象为 Windows 的安全模式，主要用于系统修复</td></tr><tr><td style="text-align:center">2, 4</td><td style="text-align:center">runlevel2.target, runlevel4.target, multi-user.target</td><td style="text-align:center">用户定义,不含 NFS 服务/域特定运行级别。默认等同于 3。</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">runlevel3.target, multi-user.target</td><td style="text-align:center">多用户，非图形化。用户可以通过多个控制台或网络登录。</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">runlevel5.target, graphical.target</td><td style="text-align:center">多用户，图形化。通常为所有运行级别 3 的服务外加图形化登录。</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">runlevel6.target, reboot.target</td><td style="text-align:center">重启</td></tr><tr><td style="text-align:center">emergency</td><td style="text-align:center">emergency.target</td><td style="text-align:center">紧急 Shell</td></tr></tbody></table><p>在 Linux 系统中可以使用 runlevel 命令来查看系统的运行级别，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># runlevel</span></span><br></pre></td></tr></table></figure><h2 id="系统初始化"><a class="header-anchor" href="#系统初始化"># </a>系统初始化</h2><p>  以centos6 为例子，在init的配置文件中有这么一行：<code>si::sysinit:/etc/rc.d/rc.sysinit</code>　它调用执行了<code>/etc/rc.d/rc.sysinit</code>，而rc.sysinit是一个bash shell的脚本，是每一个运行级别都要首先运行的重要脚本。在其中会有类似这样的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l5:5:<span class="built_in">wait</span>:/etc/rc.d/rc 5</span><br></pre></td></tr></table></figure><p>  其中数字5就是我们要运行的运行级别，这一行表示以5为参数运行<code>/etc/rc.d/rc</code>。<code>/etc/rc.d/rc</code>是一个Shell脚本，它接受5作为参数，去执行 <code>/etc/rc.d/rc5.d/</code>目录下的所有的rc启动脚本，<code>/etc/rc.d/rc5.d/</code>目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在<code>/etc/rc.d/init.d</code>/目录下。这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</p><p>  <code>/etc/rc.d/rc5.d/</code>中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以<code>/var/lock/subsys/</code>下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。</p><p>  在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&quot;System Services&quot;来自行设定。</p><h3 id="载入自定义配置"><a class="header-anchor" href="#载入自定义配置"># </a>载入自定义配置</h3><p>  在<code>/etc/rc.d/rc[0-6].d</code> 目录中的程序启动之后，系统的启动就已经完成。不过，我们总有一些程序是需要在系统启动之后随着系统一起启动的。这时我们并不需要自己把需要启动的服务链接到 /etc/rc3.d/ 目录中，因为系统给我们准备了 /etc/rc.d/rc.local 配置文件。</p><p>  这个配置文件会在用户登陆之前读取，这个文件中写入了什么命令，在每次系统启动时都会执行一次。也就是说，如果有任何需要在系统启动时运行的工作，则只需写入 /etc/rc.d/rc.local 配置文件即可。这个文件的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll /etc/rc.local</span><br><span class="line">Irwxrwxrwx. 1 root root 13 4月10 21:46 /etc/rc.local -&gt; rc.d/rc.local</span><br><span class="line">#有一个链接文件，两个文件修改哪一个都可以</span><br><span class="line">[root@localhost ~]#vi /etc/rc.d/rc.local</span><br><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line">#This script will be executed *after* all the other init scripts.</span><br><span class="line">#You can put your own initialization stuff in here if you don&apos;t</span><br><span class="line">#want to do the full Sys V style init stuff.</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">#默认会touch这个文件，每次系统启动时都会touch这个文件，这个文件的修改时间就是系统的启动时间</span><br><span class="line">/etc/rc.d/init.d/httpd start</span><br><span class="line">#如果写入RPM包安装的apache服务的启动命令，apache服务就会在开机时自动启动</span><br></pre></td></tr></table></figure><h2 id="建立终端和用户登录系统"><a class="header-anchor" href="#建立终端和用户登录系统"># </a>建立终端和用户登录系统</h2><h3 id="建立终端"><a class="header-anchor" href="#建立终端"># </a>建立终端</h3><p>  在启动过程中还有一个配置文件会生效，就是 /etc/init/start-ttys.conf，这个文件主要定义了 Linux 支持的 1~6 个本地终端（tty[1-6])。</p><p>  在inittab中的以下6行定义了6个终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1:2345:respawn:/sbin/mingetty tty1</span><br><span class="line">2:2345:respawn:/sbin/mingetty tty2</span><br><span class="line">3:2345:respawn:/sbin/mingetty tty3</span><br><span class="line">4:2345:respawn:/sbin/mingetty tty4</span><br><span class="line">5:2345:respawn:/sbin/mingetty tty5</span><br><span class="line">6:2345:respawn:/sbin/mingetty tty6</span><br></pre></td></tr></table></figure><p>  从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。</p><h3 id="用户登陆系统"><a class="header-anchor" href="#用户登陆系统"># </a>用户登陆系统</h3><p>一般来说，用户的登录方式有三种：</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录</li></ul><p>  对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。</p><p>  当通过mingetty登录时，Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数，然后对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。</p><h3 id="图形模式与文字模式的切换方式"><a class="header-anchor" href="#图形模式与文字模式的切换方式"># </a>图形模式与文字模式的切换方式</h3><p>  Linux预设提供了六个命令窗口终端机让我们来登录。</p><p>  默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。</p><p>  如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。</p><p>  如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1~F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6 切换至命令窗口。</p><hr><p>至此Linux启动完成，流程图如下</p><img src="/../assets/Linux/0/Linux启动过程.jpg" alt="Linux启动过程" style="zoom:125%;"><h2 id="linux-关机"><a class="header-anchor" href="#linux-关机"># </a>Linux 关机</h2><p>  在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>  正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt</p><p>  关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sync 将数据由内存同步到硬盘中。</span><br><span class="line"></span><br><span class="line">shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><span class="line"></span><br><span class="line">shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。</span><br><span class="line"></span><br><span class="line">shutdown –h now 立马关机</span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 系统会在今天20:25关机</span><br><span class="line"></span><br><span class="line">shutdown –h +10 十分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –r now 系统立马重启</span><br><span class="line"></span><br><span class="line">shutdown –r +10 系统十分钟后重启</span><br><span class="line"></span><br><span class="line">reboot 就是重启，等同于 shutdown –r now</span><br><span class="line"></span><br><span class="line">halt 关闭系统，等同于shutdown –h now 和 poweroff</span><br></pre></td></tr></table></figure><hr><p>  最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p><p>  关机的命令有 <strong>shutdown –h now halt poweroff</strong> 和 <strong>init 0</strong> , 重启系统的命令有 <strong>shutdown –r now reboot init 6</strong>。</p><blockquote><p><strong>参考文档地址：</strong></p><p><em>IBM Develope：<a href="https://www.ibm.com/developerworks/cn/linux/l-linuxboot/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-linuxboot/index.html</a></em></p><p><em>C语言中文网：<a href="http://c.biancheng.net/view/1014.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1014.html</a></em></p><p>菜鸟教程：<a href="https://www.runoob.com/linux/linux-system-boot.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-system-boot.html</a></p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>默认 Linux 硬件的驱动是不需要手工安装的，如果是重要的功能，则会直接编译到内核当中；如果是非重要的功能，比如硬件驱动会编译为模块，则在需要时由内核调用。不过，如果没有被内核硬件，要想驱动，就需要手工安装个硬件的硬块了。 <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 服务器端 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络常识</title>
      <link href="/note/network/BaseKnowledgeOfNetwork/"/>
      <url>/note/network/BaseKnowledgeOfNetwork/</url>
      
        <content type="html"><![CDATA[<h2 id="一-计算机网络发展的7个阶段"><a class="header-anchor" href="#一-计算机网络发展的7个阶段"># </a>一、计算机网络发展的7个阶段</h2><h3 id="第一阶段：批处理阶段"><a class="header-anchor" href="#第一阶段：批处理阶段"># </a>第一阶段：批处理阶段</h3><p>  批处理(Batch Processing)系统的出现是为了方便多人使用统一计算机而设计的。主要过程就是把卡带插入读卡机，计算机读取并计算，最后把结果通过打印机输出。</p><blockquote><p>批处理系统示意图</p></blockquote><p><img src="/assets/network/%E6%89%B9%E5%A4%84%E7%90%86.png" alt="批处理" title="批处理示意图"><br>  早期的计算机体积大，价格昂贵，通常只能在固定的场所使用，而且操作复杂，实际运行的时候有专门的操作员来处理。计算机效率低，需要等待几天才能来取。因此，批处理主要用于大规模的计算和处理，只有少数人和部门才能使用。</p><a id="more"></a><h3 id="第二阶段：分时系统"><a class="header-anchor" href="#第二阶段：分时系统"># </a>第二阶段：分时系统</h3><p>  分时系统(TSS:Time Sharing System)在20世纪60年代开始出现并流行起来。它能让多个终端与一个计算机相连，并同时使用一台计算机系统。当时计算机价格高昂，一人一台计算机不太现实，只好就通过分时系统来实现。这样每个人都能貌似独立使用计算机了(独占性)。</p><p>  分时系统有以下几个特点：<strong>多路性</strong>，<strong>独占性</strong>，<strong>交互性</strong>，<strong>及时性</strong>。</p><blockquote><p>分时系统示意图：</p></blockquote><p><img src="/assets/network/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F.jpeg" alt="分时系统示意图" title="分时系统示意图"></p><p>  终端系统类似于现在的桌面系统，采取交互式操作，终端发送指令给主机，主机将计算结果立即输出。因此，像BASIC这样的语言普及开来，更多的人可以使用计算机，小型机也随机产生。</p><h3 id="第三阶段：计算机之间的通信"><a class="header-anchor" href="#第三阶段：计算机之间的通信"># </a>第三阶段：计算机之间的通信</h3><p>  20世纪70年代，计算机性能逐步增长，体积逐渐减小，价格也逐渐降低，企业开始普及计算机。为了方便内部通信，减少磁带，软盘💾等存储介质使用，计算机之间开始链接通信线路。</p><blockquote><p>计算机内部通信示意图</p></blockquote><p><img src="/assets/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1.jpeg" alt="计算机之间通信"></p><p>  本部门的终端向通过本部门的计算机向外部门的计算机发送指令，最后再传回本部门的计算机并返回给对应终端。</p><h3 id="第四阶段：计算机网络"><a class="header-anchor" href="#第四阶段：计算机网络"># </a>第四阶段：计算机网络</h3><p>  最初的终端只能和同一厂商统一系统的计算机交互，不利于信息的传递。20世纪80年代开始，随着小型机和家用电脑的普及，为了方便不同种类，不同系统之间的通信，厂商设计了一种计算网络系统，可以通过窗口操作系统，实现个人计算机与不同种类的计算机之间的通信。</p><blockquote><p>不同网络设备的之间的通信示意图</p></blockquote><p><img src="/assets/network/%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%9A%84%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpeg" alt="不同网络设备的之间的通信示意图"></p><h3 id="第五阶段：互联网普及"><a class="header-anchor" href="#第五阶段：互联网普及"># </a>第五阶段：互联网普及</h3><p>  20世纪90年代，个人电脑已经普及，性能也大幅提升，很多个人电脑的性能不输给unix工作站，因此很多数据处理都有个人主机来完成。通过计算机“瘦身”运动，很多公司的核心系统都转移到个人电脑上。E-mail，万维网(www:world wide web)等信息传递方式逐渐普及，方便了异构计算机之间的快速通信。</p><blockquote><p>互联网示意图</p></blockquote><p><img src="/assets/network/%E4%BA%92%E8%81%94%E7%BD%91%E7%A4%BA%E6%84%8F%E5%9B%BE.jpeg" alt="互联网示意图"></p><h3 id="第六阶段：互联网中心时代"><a class="header-anchor" href="#第六阶段：互联网中心时代"># </a>第六阶段：互联网中心时代</h3><p>  互联网的普及改变了通信领域，很多不同的网络技术也想互联网靠拢，电话网，电视网逐渐被IP(Internet Protocol)网取代。</p><blockquote><p>互联网技术为中心</p></blockquote><p><img src="/assets/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E4%B8%BA%E4%B8%AD%E5%BF%83.jpeg" alt="互联网技术为中心"></p><h3 id="第七阶段：安全通信"><a class="header-anchor" href="#第七阶段：安全通信"># </a>第七阶段：安全通信</h3><p>  互联网实现了信息搜索，沟通交流，共享信息，新闻报道，远程控制等功能，成为了国家社会的基础设施最重要的环节。在便利的同时也带来了很多问题，例如信息泄露，病毒危害，网络诈骗等。计算机网路的发展已经从“简单快速的连接”转变为“安全可靠的连接”。</p><h2 id="二-网络协议"><a class="header-anchor" href="#二-网络协议"># </a>二、网络协议</h2><blockquote><p><strong>协议的定义:</strong> 协议就是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”。这种“约定”使那些由不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。反之，如果所使用的协议不同，就无法实现通信。这就好比两个人使用不同国家的语言说话，怎么也无法相互理解。协议可以分为很多种，每一种协议都明确地界定了它的行为规范。两台计算机之间必须能够支持相同的协议，并遵循相同协议进行处理，这样才能实现相互通信。</p></blockquote><h3 id="常见网络协议"><a class="header-anchor" href="#常见网络协议"># </a>常见网络协议</h3><table><thead><tr><th style="text-align:center">网络体系结构</th><th style="text-align:center">协议</th><th style="text-align:center">主要用途</th></tr></thead><tbody><tr><td style="text-align:center">TCP/IP</td><td style="text-align:center">IP,ICMP,TCP,UDP,HTTP,TELNET,SNTP,SMTP…</td><td style="text-align:center">互联网，局域网</td></tr><tr><td style="text-align:center">IPX/SPX(NetWare)</td><td style="text-align:center">IPX,SPX,NPC…</td><td style="text-align:center">个人电脑局域网</td></tr><tr><td style="text-align:center">AppleTalk</td><td style="text-align:center">DDP,RTMP,AEP,ATP,ZIP…</td><td style="text-align:center">苹果公司产品局域网</td></tr></tbody></table><h3 id="协议诞生及标准化"><a class="header-anchor" href="#协议诞生及标准化"># </a>协议诞生及标准化</h3><ol><li>1974年，IBM发布SNA，将本公司的通信协议公之于众，其他厂商也纷纷发布自己的协议，引发了众多协议的系统话进程，但是协议之间并不兼容，无法实现通信</li><li>ISO制定了一个国际标准OSI(Open System Interconnection: “开放式通信系统互联参考模型”)。OSI并未普及但是OSI参考模型常被用于网络协议的制定当中。</li><li>IETF所建立的TCP/IP模型，被大学等研究机构和计算机行业推行，成为互联网协议的行业标准。</li></ol><h3 id="协议分层与osi参考模型"><a class="header-anchor" href="#协议分层与osi参考模型"># </a>协议分层与OSI参考模型</h3><p>  协议分层使得复杂的的网络协议简单化。每一个分层接受下一层提供的服务，并负责向上一层提供服务，上下层之间的交互遵循的约定叫 <strong>“接口”</strong> ,同一层交互遵循的约定叫 <strong>“协议”</strong> 。</p><p> OSI模型将协议分为七层：</p><p><img src="/assets/network/OSI%E6%A8%A1%E5%9E%8B.png" alt="OSI模型"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 网络 </tag>
            
            <tag> OSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6中的数据类型判断</title>
      <link href="/note/web/ecmascript/es6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
      <url>/note/web/ecmascript/es6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="es6中的数据类型判断的几种方式"><a class="header-anchor" href="#es6中的数据类型判断的几种方式"># </a>ES6中的数据类型判断的几种方式</h2><h3 id="1-typeof"><a class="header-anchor" href="#1-typeof"># </a>1.typeof</h3><p>typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型,返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：</p><ul><li>number、</li><li>boolean、</li><li>symbol、</li><li>string、</li><li>object、</li><li>undefined、</li><li>function 等。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">''</span>; <span class="comment">// string 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// number 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// symbol 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">//boolean 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">//undefined 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> [] ; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>(); <span class="comment">// function 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//object 无效</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>总结：</strong></p><ul><li>对于基本类型，除 null 以外，均可以返回正确的结果。</li><li>对于引用类型，除 function 以外，一律返回 object 类型。</li><li>对于 null ，返回 object 类型。</li><li>对于 function 返回 function 类型。</li></ul><h3 id="2-instanceof"><a class="header-anchor" href="#2-instanceof"># </a>2.instanceof</h3><ul><li>instanceof 检测的是原型对象。</li><li>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B。</li><li>如果 A 是 B 的实例，则返回 true,否则返回 false。</li><li>当 A 的 <strong>proto</strong> 指向 B 的 prototype 时，就认为 A 就是 B 的实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>;<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> Person;</span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Person <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>原型链举例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[].__proto__ --&gt; <span class="built_in">Array</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.__proto__ --&gt; <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ --&gt;<span class="literal">null</span></span><br></pre></td></tr></table></figure><p><strong>问题总结：</strong></p><ul><li>instanceof 只能用来判断两个对象是否属于实例关系，而不能判断一个对象实例具体属于哪种类型。</li><li>它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">xArray = <span class="built_in">window</span>.frames[<span class="number">0</span>].Array;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> xArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">   <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array.isArray() 本质上检测的是对象的 [[Class]] 值，[[Class]] 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 [object Xxx] ，Xxx 就是对应的具体类型 。对于数组而言，[[Class]] 的值就是 [object Array] 。</p><h3 id="3-constructor"><a class="header-anchor" href="#3-constructor"># </a>3.constructor</h3><ul><li>当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用</li><li>当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor == F</li><li>F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</li></ul><p><strong>注意：</strong></p><ul><li>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</li><li>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</li></ul><h3 id="4-tostring"><a class="header-anchor" href="#4-tostring"># </a>4.toString</h3><ul><li>toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</li><li>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) ;   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ; <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ; <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) ; <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) ; <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) ; <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ; <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ; <span class="comment">//[object global] window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a class="header-anchor" href="#总结"># </a>总结</h2><p><strong>typeof：</strong></p><ul><li>可判断<ul><li>数值</li><li>字符串</li><li>布尔值</li><li>undefined</li><li>function</li></ul></li><li>不可判断<ul><li>null</li><li>object</li><li>array</li></ul></li></ul><p><strong>instance：</strong></p><ul><li>判断对象具体类型</li></ul><p><strong>全等于：</strong></p><ul><li>null/undefined</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> EcmaScript </category>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> EcmaScript </tag>
            
            <tag> ES6 </tag>
            
            <tag> 类型判断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo—Next自定义修改日志</title>
      <link href="/log/"/>
      <url>/log/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>本文用于记录本站每次更新的详情</p></blockquote><h2 id="2019-11-19-第一次修改"><a class="header-anchor" href="#2019-11-19-第一次修改"># </a>2019/11/19 第一次修改</h2><p>博客引用了hexo的next主题，主题github地址为<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a>,按照<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">官方文档</a>的介绍精心了初步配置</p><h3 id="把hexo项目同步到git中存储"><a class="header-anchor" href="#把hexo项目同步到git中存储"># </a>把hexo项目同步到git中存储</h3><p>为了将将项目文档同步到git中，保护自己在配置中的各类网站的key，按照官方的建议，把主题配置的_config.yml内容拷贝到了 /source/_data/next.yml中，上传到了自己的私有git仓库中</p><a id="more"></a><h3 id="目录结构的修改"><a class="header-anchor" href="#目录结构的修改"># </a>目录结构的修改</h3><p>方便以后查阅自己的笔记总结，新建了一个page笔记页面，并自定义了笔记目录，由与内容比较多就，接下来会逐步更新</p><h3 id="对next主题的自定义修改"><a class="header-anchor" href="#对next主题的自定义修改"># </a>对Next主题的自定义修改</h3><h4 id="在页尾添加自定义的图文footer-banner"><a class="header-anchor" href="#在页尾添加自定义的图文footer-banner"># </a>在页尾添加自定义的图文footer-banner</h4><p>在查阅官方的Muse主题的案例推荐后，看到<a href="https://leaferx.online/" target="_blank" rel="noopener">leaferx</a>文档下有一个自定义的图片banner比较有范，于是查阅了博主的样式设置，由于对swig语法还不太熟悉，就简单粗暴的修改了原始模版，具体方法如下</p><p>在next主题的 _layout/_layout.swfg 的footer标签，footer-inner class 上添加如下标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.custom-banner</span>&#123;</span></span><br><span class="line">    background-attachment: fixed;</span><br><span class="line">    background-position: center bottom;</span><br><span class="line">    padding: 40px 0;</span><br><span class="line">    margin-bottom: 40px;</span><br><span class="line">    background-size: 100%;</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>);</span></span><br><span class="line">    background-image: url(/images/sea.jpg);</span><br><span class="line">    background-blend-mode: darken;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.custom-banner</span> <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line">    text-align: center;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    font-family: fira code,consolas,Menlo,pingfang sc,microsoft yahei,monospace;</span><br><span class="line">    font-style: italic;</span><br><span class="line">    font-weight: 400;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"custom-banner"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Stay hungary,Stay foolish.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="引入iconfont"><a class="header-anchor" href="#引入iconfont"># </a>引入iconfont</h4><p>由于Next主题使用的fontawsome免费的icon数量不是很多，而且版本比较老旧，因此使用iconfont的图标来丰富博客的图标库，网站链接在此<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></p><p><strong>修改方法：</strong></p><p>为了方便日后直接使用，在next主题的 _layout/_layout.swfg 的头部文件中的&lt;head&gt;便签末尾插入以下<code>html</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在iconfont生成项目后，每次添加不同的icon都会改变src地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//at.alicdn.com/t/font_1078070_hs0wiix70l.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.icon</span> &#123;</span></span><br><span class="line">    width: 1em; height: 1em;</span><br><span class="line"><span class="css">    <span class="selector-tag">vertical-align</span>: <span class="selector-tag">-0</span><span class="selector-class">.15em</span>;</span></span><br><span class="line">    fill: currentColor;</span><br><span class="line">    overflow: hidden;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>随后在需要使用的markdown文档中使用以下标签可以使用iconfont图标,href的内容为iconfont项目内的图标标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#icon-php"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><h4 id="将站点地图放置到页脚"><a class="header-anchor" href="#将站点地图放置到页脚"># </a>将站点地图放置到页脚</h4><p>站点地图是为了方便搜索引擎爬去信息，在layout/_partials/footer.swig中，将以下html添加到span.author标签下方</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-map"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>站点地图:<span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/sitemap.xml"</span> <span class="attr">style</span>=<span class="string">"color:#999"</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span>/</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/baidusitemap.xml"</span> <span class="attr">style</span>=<span class="string">"color:#999"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
          <category> Blog设置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> Nexo </tag>
            
            <tag> Next </tag>
            
            <tag> 主题 </tag>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start"><a class="header-anchor" href="#quick-start"># </a>Quick Start</h2><a id="more"></a><h3 id="create-a-new-post"><a class="header-anchor" href="#create-a-new-post"># </a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><a class="header-anchor" href="#run-server"># </a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="header-anchor" href="#generate-static-files"># </a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="header-anchor" href="#deploy-to-remote-sites"># </a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
