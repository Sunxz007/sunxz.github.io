<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络常识</title>
      <link href="/note/network/BaseKnowledgeOfNetwork/"/>
      <url>/note/network/BaseKnowledgeOfNetwork/</url>
      
        <content type="html"><![CDATA[<h2 id="一-计算机网络发展的7个阶段"><a class="header-anchor" href="#一-计算机网络发展的7个阶段"># </a>一、计算机网络发展的7个阶段</h2><h3 id="第一阶段：批处理阶段"><a class="header-anchor" href="#第一阶段：批处理阶段"># </a>第一阶段：批处理阶段</h3><p>  批处理(Batch Processing)系统的出现是为了方便多人使用统一计算机而设计的。主要过程就是把卡带插入读卡机，计算机读取并计算，最后把结果通过打印机输出。</p><blockquote><p>批处理系统示意图</p></blockquote><p><img src="/assets/network/%E6%89%B9%E5%A4%84%E7%90%86.png" alt="批处理" title="批处理示意图"><br>  早期的计算机体积大，价格昂贵，通常只能在固定的场所使用，而且操作复杂，实际运行的时候有专门的操作员来处理。计算机效率低，需要等待几天才能来取。因此，批处理主要用于大规模的计算和处理，只有少数人和部门才能使用。</p><a id="more"></a><h3 id="第二阶段：分时系统"><a class="header-anchor" href="#第二阶段：分时系统"># </a>第二阶段：分时系统</h3><p>  分时系统(TSS:Time Sharing System)在20世纪60年代开始出现并流行起来。它能让多个终端与一个计算机相连，并同时使用一台计算机系统。当时计算机价格高昂，一人一台计算机不太现实，只好就通过分时系统来实现。这样每个人都能貌似独立使用计算机了(独占性)。</p><p>  分时系统有以下几个特点：<strong>多路性</strong>，<strong>独占性</strong>，<strong>交互性</strong>，<strong>及时性</strong>。</p><blockquote><p>分时系统示意图：</p></blockquote><p><img src="/assets/network/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F.jpeg" alt="分时系统示意图" title="分时系统示意图"></p><p>  终端系统类似于现在的桌面系统，采取交互式操作，终端发送指令给主机，主机将计算结果立即输出。因此，像BASIC这样的语言普及开来，更多的人可以使用计算机，小型机也随机产生。</p><h3 id="第三阶段：计算机之间的通信"><a class="header-anchor" href="#第三阶段：计算机之间的通信"># </a>第三阶段：计算机之间的通信</h3><p>  20世纪70年代，计算机性能逐步增长，体积逐渐减小，价格也逐渐降低，企业开始普及计算机。为了方便内部通信，减少磁带，软盘💾等存储介质使用，计算机之间开始链接通信线路。</p><blockquote><p>计算机内部通信示意图</p></blockquote><p><img src="/assets/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1.jpeg" alt="计算机之间通信"></p><p>  本部门的终端向通过本部门的计算机向外部门的计算机发送指令，最后再传回本部门的计算机并返回给对应终端。</p><h3 id="第四阶段：计算机网络"><a class="header-anchor" href="#第四阶段：计算机网络"># </a>第四阶段：计算机网络</h3><p>  最初的终端只能和同一厂商统一系统的计算机交互，不利于信息的传递。20世纪80年代开始，随着小型机和家用电脑的普及，为了方便不同种类，不同系统之间的通信，厂商设计了一种计算网络系统，可以通过窗口操作系统，实现个人计算机与不同种类的计算机之间的通信。</p><blockquote><p>不同网络设备的之间的通信示意图</p></blockquote><p><img src="/assets/network/%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%9A%84%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpeg" alt="不同网络设备的之间的通信示意图"></p><h3 id="第五阶段：互联网普及"><a class="header-anchor" href="#第五阶段：互联网普及"># </a>第五阶段：互联网普及</h3><p>  20世纪90年代，个人电脑已经普及，性能也大幅提升，很多个人电脑的性能不输给unix工作站，因此很多数据处理都有个人主机来完成。通过计算机“瘦身”运动，很多公司的核心系统都转移到个人电脑上。E-mail，万维网(www:world wide web)等信息传递方式逐渐普及，方便了异构计算机之间的快速通信。</p><blockquote><p>互联网示意图</p></blockquote><p><img src="/assets/network/%E4%BA%92%E8%81%94%E7%BD%91%E7%A4%BA%E6%84%8F%E5%9B%BE.jpeg" alt="互联网示意图"></p><h3 id="第六阶段：互联网中心时代"><a class="header-anchor" href="#第六阶段：互联网中心时代"># </a>第六阶段：互联网中心时代</h3><p>  互联网的普及改变了通信领域，很多不同的网络技术也想互联网靠拢，电话网，电视网逐渐被IP(Internet Protocol)网取代。</p><blockquote><p>互联网技术为中心</p></blockquote><p><img src="/assets/network/%E4%BA%92%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E4%B8%BA%E4%B8%AD%E5%BF%83.jpeg" alt="互联网技术为中心"></p><h3 id="第七阶段：安全通信"><a class="header-anchor" href="#第七阶段：安全通信"># </a>第七阶段：安全通信</h3><p>  互联网实现了信息搜索，沟通交流，共享信息，新闻报道，远程控制等功能，成为了国家社会的基础设施最重要的环节。在便利的同时也带来了很多问题，例如信息泄露，病毒危害，网络诈骗等。计算机网路的发展已经从“简单快速的连接”转变为“安全可靠的连接”。</p><h2 id="二-网络协议"><a class="header-anchor" href="#二-网络协议"># </a>二、网络协议</h2><blockquote><p><strong>协议的定义:</strong> 协议就是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”。这种“约定”使那些由不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。反之，如果所使用的协议不同，就无法实现通信。这就好比两个人使用不同国家的语言说话，怎么也无法相互理解。协议可以分为很多种，每一种协议都明确地界定了它的行为规范。两台计算机之间必须能够支持相同的协议，并遵循相同协议进行处理，这样才能实现相互通信。</p></blockquote><h3 id="常见网络协议"><a class="header-anchor" href="#常见网络协议"># </a>常见网络协议</h3><table><thead><tr><th style="text-align:center">网络体系结构</th><th style="text-align:center">协议</th><th style="text-align:center">主要用途</th></tr></thead><tbody><tr><td style="text-align:center">TCP/IP</td><td style="text-align:center">IP,ICMP,TCP,UDP,HTTP,TELNET,SNTP,SMTP…</td><td style="text-align:center">互联网，局域网</td></tr><tr><td style="text-align:center">IPX/SPX(NetWare)</td><td style="text-align:center">IPX,SPX,NPC…</td><td style="text-align:center">个人电脑局域网</td></tr><tr><td style="text-align:center">AppleTalk</td><td style="text-align:center">DDP,RTMP,AEP,ATP,ZIP…</td><td style="text-align:center">苹果公司产品局域网</td></tr></tbody></table><h3 id="协议诞生及标准化"><a class="header-anchor" href="#协议诞生及标准化"># </a>协议诞生及标准化</h3><ol><li>1974年，IBM发布SNA，将本公司的通信协议公之于众，其他厂商也纷纷发布自己的协议，引发了众多协议的系统话进程，但是协议之间并不兼容，无法实现通信</li><li>ISO制定了一个国际标准OSI(Open System Interconnection: “开放式通信系统互联参考模型”)。OSI并未普及但是OSI参考模型常被用于网络协议的制定当中。</li><li>IETF所建立的TCP/IP模型，被大学等研究机构和计算机行业推行，成为互联网协议的行业标准。</li></ol><h3 id="协议分层与osi参考模型"><a class="header-anchor" href="#协议分层与osi参考模型"># </a>协议分层与OSI参考模型</h3><p>  协议分层使得复杂的的网络协议简单化。每一个分层接受下一层提供的服务，并负责向上一层提供服务，上下层之间的交互遵循的约定叫 <strong>“接口”</strong> ,同一层交互遵循的约定叫 <strong>“协议”</strong> 。</p><p> OSI模型将协议分为七层：</p><p><img src="/assets/network/OSI%E6%A8%A1%E5%9E%8B.png" alt="OSI模型"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 基础 </tag>
            
            <tag> OSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统启动过程</title>
      <link href="/note/server/linux/LinuxBootProcess/"/>
      <url>/note/server/linux/LinuxBootProcess/</url>
      
        <content type="html"><![CDATA[<p>  Linux系统的启动，从计算机开机通电自检开始，一直到登陆系统，总共经历如下几个过程：</p><ol><li>服务器加电，加载 BIOS 信息，BIOS 进行系统检测。依照 BIOS 设定，找到第一个可以启动的设备（一般是硬盘）；</li><li>读取第一个启动设备的 MBR (主引导记录），加载 MBR 中的 Boot Loader（启动引导程序，最为常见的是 GRUB）。</li><li>依据 Boot Loader 的设置加载内核，内核会再进行一遍系统检测。系统一般会采用内核检测硬件的信息，而不一定采用 Bios 的自检信息。内核在检测硬件的同时，还会通过加载动态模块的形式加载硬件的驱动。</li><li>内核启动系统的第一个进程，也就是 /sbin/init。</li><li>由 /sbin/init 进程调用/etc目录下的init程序 ，来配置计算机的初始环境、确定系统的默认运行级别。</li><li>确定默认运行级别后，调用 /etc/init/rc.conf 配置文件初始化系统，然后执行 /etc/rc.d/rc.local 中的程序。</li><li>如果是终端界面启动，就可以看到登录界面了。如果是图形界面启动，就会调用相应的 X Window 接口。</li></ol><a id="more"></a><hr><p>  总的来说Linux启动过程大致分为五个过程:<code>BIOS启动-&gt;内核引导过程-&gt;运行init(初始化配置文件)-&gt;系统初始化-&gt;建立终端或载入用户登陆系统</code></p><h2 id="硬件启动与引导"><a class="header-anchor" href="#硬件启动与引导"># </a>硬件启动与引导</h2><h3 id="biso启动"><a class="header-anchor" href="#biso启动"># </a>BISO启动</h3><p>  BIOS 全称 Basic Input/Output System，中文可译为基本输入/输出系统。它是固化在主板上一个 ROM（只读存储器）芯片上的程序，主要保存计算机的基本输入/输出信息、系统设置信息、开机自检程和系统自启动程序，用来为 计算机提供最底层和最直接的硬件设置与控制。BIOS 的初始化主要完成以下 几 项工作：</p><ol><li>当 BIOS 一启动，就会检查计算机硬件和外围设备（例如 CPU、内存、风扇灯），整个自检过程也被称为 POST（Power On Self Test）自检。</li><li>如果自检没有问题，BIOS 开始对硬件进行初始化，并规定当前可启动设备的先后顺序，选择由那个设备来开机。</li><li>选择好开启设备后，就会从该设备的 MBR（主引导目录）中读取 Boot Loader（启动引导程序）并执行。启动引导程序用于引导操作系统启动，Linux系统中默认使用的启动引导程序是 GRUB。</li><li>当 MBR 被加载到 RAM 之后，BIOS 就会将控制权交给 MBR，进入系统引导的第二阶段。</li></ol><h3 id="读取mbr"><a class="header-anchor" href="#读取mbr"># </a>读取MBR</h3><p>  MBR 也就是主引导记录，最主要的功能就是存储启动引导程序。MBR位于硬盘的 0 磁道、0 柱面、1 扇区中，主要记录了启动引导程序和磁盘的分区表。MBR 共占用了一个扇区，也就是 512 Byte。其中 446 Byte 安装了启动引导程序，其后 64 Byte 描述分区表，最后的 2 Byte 是结束标记。</p><blockquote><p>MBR结构图：</p></blockquote><p><img src="/../assets/Linux/0/MDR%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="MDR结构图"></p><p>  之所以每块硬盘只能划分四个分区，原因就是在 MBR 中描述分区表的空间只有 64 Byte。其中每个分区必须占用 16 Byte，那么 64 Byte 就只能划分 4 个主分区。每个分区的 16 字节的规划如表 ：</p><table><thead><tr><th style="text-align:center">存储字节</th><th style="text-align:center">数据内容及含义</th></tr></thead><tbody><tr><td style="text-align:center">第 1 字节</td><td style="text-align:center">引导标志</td></tr><tr><td style="text-align:center">第 2 字节</td><td style="text-align:center">本分区的起始磁道号</td></tr><tr><td style="text-align:center">第 3 字节</td><td style="text-align:center">本分区的起始扇区号</td></tr><tr><td style="text-align:center">第 4 字节</td><td style="text-align:center">本分区的起始柱面号</td></tr><tr><td style="text-align:center">第 5 字节</td><td style="text-align:center">分区类型，可以识别主分区和扩展分区</td></tr><tr><td style="text-align:center">第 6 字节</td><td style="text-align:center">本分区的结束磁道号</td></tr><tr><td style="text-align:center">第 7 字节</td><td style="text-align:center">本分区的结束扇区号</td></tr><tr><td style="text-align:center">第 8 字节</td><td style="text-align:center">本分区的结束柱面号</td></tr><tr><td style="text-align:center">第 9~12 字节</td><td style="text-align:center">本分区之前已经占用的扇区数</td></tr><tr><td style="text-align:center">第 13~16 字节</td><td style="text-align:center">本分区的总扇区数</td></tr></tbody></table><h4 id="启动引导程序的作用"><a class="header-anchor" href="#启动引导程序的作用"># </a>启动引导程序的作用</h4><p>  BIOS 的作用就是自检，然后从 MBR 中读取出启动引导程序，所以，启动引导程序最主要的作用就是加载操作系统的内核。由于每种操作系统的文件格式不同，因此每种操作系统的启动引导程序也不一样。不同的操作系统只有使用自己的启动引导程序才能加载自己的内核。如果服务器中安装了多个操作系统，而 MBR 只有一 个，那么明显是不够用的。</p><p>  然而每块硬盘只能有一个 MBR 是不能更改的，所以不可能増加 MBR 的数量。系统只能在每个文件系统（可以看成分区）中单独划分出一个扇区，称作引导扇区（Boot Sector)。每个分区的引导扇区中也能安装启动引导程序，也就是说，在 MBR 和每个单独分区的引导扇区中都可以安装启动引导程序。这样多个操作系统才能安装在同一台服务器中（每个操作系统要安装在不同的分区中），而且每个操作系统都是可以启动的。</p><p>  但是BIOS 只能找到 MBR 中的启动引导程序，而找不到在分区的引导扇区中的启动引导程序。如果要想完成多系统启动，那么就要増加启动引导程序的功能，让安装到 MBR 中的启动引导程序（GRUB）来调用在分区的引导扇区中的其他启动引导程序。</p><p>因此，启动引导程序拥有以下功能：</p><ol><li>加载操作系统的内核。这是启动引导程序最主要的功能。</li><li>拥有一个可以让用户选择的菜单，来选择到底启动哪个系统。大家如果在服务器上安装过双 Windows 系统，就应该见过类似的选择菜单，不过这个选择菜单是由 Windows 的启动引导程序提供的，而不是 GRUB。</li><li>可以调用其他的启动引导程序，这是多系统启动的关键。不过需要注意的是，Windows 的启动引导程序不能调用 Linux的启动引导程序，所以我们一般建议先安装 Windows，后安装 Linux，是为了将 Linux 的启动引导程序安装到 MBR 中，覆盖 Windows 的启动引导程序。</li></ol><p>启动引导程序的作用示意图：</p><img src="/../assets/Linux/0/MBR的作用.jpg" alt="MBR的作用" style="zoom:125%;"><h2 id="linux内核模块加载"><a class="header-anchor" href="#linux内核模块加载"># </a>Linux内核模块加载</h2><p>  GRUB 加载了内核之后，内核首先会再进行二次系统的自检，而不一定使用 BIOS 检测的硬件信息。这时内核终于开始替代 BIOS 接管 Linux的启动过程了。</p><p>  内核再次系统自检后，就会开始动态加载每个硬件的模块，这个动态模块大家可以想象成硬件的驱动<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。Linux 的内核存放在 /boot 的启动目录中。</p><figure class="highlight bash"><figcaption><span>/boot目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#ls /boot/</span></span><br><span class="line">config-2.6.32-279.el6.i686 <span class="comment">#内核的配置文件，内核编译时选择的功能与模块</span></span><br><span class="line">efi <span class="comment">#可扩展固件接口，为英特尔为全新PC固件的体系结构、接口和服务提出的建议标准</span></span><br><span class="line">grub <span class="comment">#启动引导程GTUB的数据目录</span></span><br><span class="line">initramfe-2.6.32-279.el6.i686.img <span class="comment">#虚拟文件系统（CentOS 6.x 中用initramfs替代了initrd,但功能是一样的）</span></span><br><span class="line">lost+found <span class="comment"># boot分区的备份目录</span></span><br><span class="line">symvers-2_6.32-279.el6.i686.gz <span class="comment">#模块符号信息</span></span><br><span class="line">System.map-2.6.32-279.el6.i686 <span class="comment">#内核功能和内存地址的对应列表</span></span><br><span class="line">vmlinuz-2.6.32-279.el6.i686 <span class="comment">#用于启动的Linux内核。这个文件是一个压缩的内核镜像</span></span><br></pre></td></tr></table></figure><p>  Linux 为了保证了内核不会过大，会把不重要的功能编译成内核模块，在需要时再调用。在多数 Linux 中，都会把硬件的驱动程序编译为模块， 这些模块保存在 /lib/modules 目录中。常见的 USB、SATA 和 SCSI 等硬盘设备的驱动，还有一些特殊的文件系统（如 LVM、RAID 等）的驱动，都是以模块的方式来保存的。</p><p>  如果 Linux 安装在 IDE 硬盘之上，并且采用的是默认的 ext3/4 文件系统，那么内核启动后加载根分区和模块的加载都没有什么问题。如果要将 Linux 安装在 SCSI 硬盘之上，或者采用的是 LVM 文件系统，那么内核（内核载入内存是启动引导程序 GRUB 调用的，并不存在硬盘驱动不识别的问题）在加载根目录之前是需要加载 SCSI 硬盘或 LVM 文件系统的驱动的。而SCSI 硬盘和 LVM 文件系统的驱动都放在硬盘的 /lib/modules 目录中，内核没有办法识别 ，因此Linux 采用了 initramfs 这个虚拟文件系统来处理这个问题。</p><h3 id="initramfe虚拟文件系统"><a class="header-anchor" href="#initramfe虚拟文件系统"># </a>initramfe虚拟文件系统</h3><p>  CentOS 6.x 中使用 initramfs 虚拟文件系统取代了 CentOS 5.x 中的 initrd RAM Disk。它们的作用类似，可以通过 initramfs 虚拟文件系统在内存中模拟出一个根目录，然后在这个模拟根目录中加载 SCSI 等硬件的驱动，就可以加载真正的根目录了，之后才能调用 Linux 的第一个进程 /sbin/init。</p><p>Initramfs 虚拟文件系统主要有以下优点：</p><ul><li>initramfs 随着其中数据的増减自动増减容量。</li><li>在 initramfs 和页面缓存之间没有重复数据。</li><li>initramfs 重复利用了 Linux caching 的代码，因此几乎没有増加内核尺寸，而 caching 的代码已经经过良好测试，所以 initramfs 的代码质量也有保证。</li><li>不需要额外的文件系统驱动</li></ul><img src="/../assets/Linux/0/initramfe虚拟文件系统.jpg" alt="initramfe虚拟文件系统" style="zoom:125%;"><hr><p>  内核启动后，首先会去解析grub的配置文件<code>/boot/grub/grub.conf</code>，然后加载内核镜像到内存中，并将控制权转交给内核。而内核会立即初始化系统中各设备并做相关的配置工作，其中包括CPU、I/O、存储设备等。在内核加载完毕，系统开始运行第一个进程。</p><h2 id="第一个进程：init"><a class="header-anchor" href="#第一个进程：init"># </a>第一个进程：init</h2><p>  在内核加载完毕，并完成硬件检测与驱动程序加载后，此时主机硬件已经准备完毕，内核会主动呼叫第一个进程，也就是 /sbin/init，此配置文件最主要的功能就是准备软件执行的环境，包括系统的主机名、网络设定、语言、文件系统格式及其他服务的启动等。</p><p>  由于Linux内核的不断发展，各个发行版、各个版本的操作系统，采用的init程序配置系统完全不同。基本上是由 /sbin/init 进程来 <strong>配置计算机的初始环境</strong> 和 <strong>确定系统的默认运行级别</strong>。</p><p>  例如在 CentOS 6.x 系统中，由于用 Upstart 启动服务来替换以前的 init，所以在 /etc/inittab 配置文件中只能定义系统的默认运行级别，而其他的功能是靠 /etc/init/ 目录中的其他配置文件实现的。</p><blockquote><p>init程序的类型举例：</p><ul><li><p><strong>SysV:</strong> init, CentOS 5之前, 配置文件： <code>/etc/inittab。</code></p></li><li><p><strong>Upstart:</strong> init,CentOS 6, 配置文件：<code>/etc/inittab</code>,<code>/etc/init/*.conf。</code></p></li><li><p><strong>Systemd：</strong> systemd, CentOS 7,配置文件：<code>/usr/lib/systemd/system</code>、<code>/etc/systemd/system</code>。</p></li></ul><p>关于init系统的介绍，可以阅读以下文章：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html" target="_blank" rel="noopener">浅谈SysVinit</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/index.html" target="_blank" rel="noopener">浅谈Upstart</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html" target="_blank" rel="noopener">浅谈Systemd</a></li></ul></blockquote><h3 id="配置计算机的初始环境"><a class="header-anchor" href="#配置计算机的初始环境"># </a>配置计算机的初始环境</h3><p>  以centos 6采用的Upstart系统举例， /sbin/init 进程通过 /etc/init/rcS.conf 配置文件，分别找到 /etc/rc.d/rc.sysinit 配置文件和 /etc/inittab 配置文件，前者用于初始化系统，配置计算机的初始环境；后者用于确定系统的默认运行级别。用 Vim 查看 /etc/rc.d/rc.sysinit 配置文件，就会发现这个这个配置文件主要进行了以下几项工作：</p><ul><li>获得网络环境和主机类型；</li><li>测试设备：除了挂载内存设备 /proc 之外，还会主动侦测系统上是否具有 usb 设备，如果有，则会主动加载 usb 的驱动程序，并尝试挂载 usb 文件系统；</li><li>开机启动画面 Plymouth（代替了以往的 RHGB）；</li><li>判断是否启用 SELinux；</li><li>显示开机过程中的欢迎画面；</li><li>初始化硬件；</li><li>用户自定义模块的加载，用户可以在<code>/etc/sysconfig/modules/*.modules</code> 加入自订的模块，则此时会被加载到系统当中；</li><li>配置内核的参数，系统会主动去读取<code>/etc/sysctl.conf</code>这个文件的配置参数，使内核的功能成为我们想要的样子。</li><li>设置主机名。</li><li>同步存储器。</li><li>设备映射器及相关的初始化。</li><li>初始化软件磁盘阵列 (RAID)。</li><li>初始化 LVM 的文件系统功能。</li><li>检验磁盘文件系统 (fsck)。</li><li>设置磁盘配额 (quota)。</li><li>重新以可读写模式挂载系统磁盘。</li><li>更新 quota (非必要)。</li><li>启动系统虚拟随机数生成器。</li><li>配置机器（非必要）。</li><li>清除开机过程中的临时文件。</li><li>创建 ICE 目录。</li><li>启动交换分区（swap）。</li><li>将开机信息写入<code>/var/log/dmesg</code> 文件中。</li></ul><p>  <code>/etc/rc.d/rc.sysinit</code>配置文件已经将基本的系统配置数据都写好了，我们可以查询 <code>/var/log/dmesg</code>文件或使用 dmesg 命令查看系统在启动时到底发生了什么。当然，我们也可以通过这个命令来看看 Linux 服务器的硬件信息。</p><h3 id="配置运行级别"><a class="header-anchor" href="#配置运行级别"># </a>配置运行级别</h3><p>  在 CentOS 6.x 中，/etc/inittab 配置文件只能用来设置系统的默认运行级别。而在systemd 系统中，采用目标（target）替代了运行级别的概念，这里展示了Sysvinit 运行级别和 systemd 目标的对应表。</p><table><thead><tr><th style="text-align:center">Sysvinit 运行级别</th><th style="text-align:center">Systemd 目标</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">runlevel0.target, poweroff.target</td><td style="text-align:center">关闭系统。</td></tr><tr><td style="text-align:center">1, s, single</td><td style="text-align:center">runlevel1.target, rescue.target</td><td style="text-align:center">单用户模式。可以想象为 Windows 的安全模式，主要用于系统修复</td></tr><tr><td style="text-align:center">2, 4</td><td style="text-align:center">runlevel2.target, runlevel4.target, multi-user.target</td><td style="text-align:center">用户定义,不含 NFS 服务/域特定运行级别。默认等同于 3。</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">runlevel3.target, multi-user.target</td><td style="text-align:center">多用户，非图形化。用户可以通过多个控制台或网络登录。</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">runlevel5.target, graphical.target</td><td style="text-align:center">多用户，图形化。通常为所有运行级别 3 的服务外加图形化登录。</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">runlevel6.target, reboot.target</td><td style="text-align:center">重启</td></tr><tr><td style="text-align:center">emergency</td><td style="text-align:center">emergency.target</td><td style="text-align:center">紧急 Shell</td></tr></tbody></table><p>在 Linux 系统中可以使用 runlevel 命令来查看系统的运行级别，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># runlevel</span></span><br></pre></td></tr></table></figure><h2 id="系统初始化"><a class="header-anchor" href="#系统初始化"># </a>系统初始化</h2><p>  以centos6 为例子，在init的配置文件中有这么一行：<code>si::sysinit:/etc/rc.d/rc.sysinit</code>　它调用执行了<code>/etc/rc.d/rc.sysinit</code>，而rc.sysinit是一个bash shell的脚本，是每一个运行级别都要首先运行的重要脚本。在其中会有类似这样的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l5:5:<span class="built_in">wait</span>:/etc/rc.d/rc 5</span><br></pre></td></tr></table></figure><p>  其中数字5就是我们要运行的运行级别，这一行表示以5为参数运行<code>/etc/rc.d/rc</code>。<code>/etc/rc.d/rc</code>是一个Shell脚本，它接受5作为参数，去执行 <code>/etc/rc.d/rc5.d/</code>目录下的所有的rc启动脚本，<code>/etc/rc.d/rc5.d/</code>目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在<code>/etc/rc.d/init.d</code>/目录下。这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</p><p>  <code>/etc/rc.d/rc5.d/</code>中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以<code>/var/lock/subsys/</code>下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。</p><p>  在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&quot;System Services&quot;来自行设定。</p><h3 id="载入自定义配置"><a class="header-anchor" href="#载入自定义配置"># </a>载入自定义配置</h3><p>  在<code>/etc/rc.d/rc[0-6].d</code> 目录中的程序启动之后，系统的启动就已经完成。不过，我们总有一些程序是需要在系统启动之后随着系统一起启动的。这时我们并不需要自己把需要启动的服务链接到 /etc/rc3.d/ 目录中，因为系统给我们准备了 /etc/rc.d/rc.local 配置文件。</p><p>  这个配置文件会在用户登陆之前读取，这个文件中写入了什么命令，在每次系统启动时都会执行一次。也就是说，如果有任何需要在系统启动时运行的工作，则只需写入 /etc/rc.d/rc.local 配置文件即可。这个文件的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll /etc/rc.local</span><br><span class="line">Irwxrwxrwx. 1 root root 13 4月10 21:46 /etc/rc.local -&gt; rc.d/rc.local</span><br><span class="line">#有一个链接文件，两个文件修改哪一个都可以</span><br><span class="line">[root@localhost ~]#vi /etc/rc.d/rc.local</span><br><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line">#This script will be executed *after* all the other init scripts.</span><br><span class="line">#You can put your own initialization stuff in here if you don&apos;t</span><br><span class="line">#want to do the full Sys V style init stuff.</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">#默认会touch这个文件，每次系统启动时都会touch这个文件，这个文件的修改时间就是系统的启动时间</span><br><span class="line">/etc/rc.d/init.d/httpd start</span><br><span class="line">#如果写入RPM包安装的apache服务的启动命令，apache服务就会在开机时自动启动</span><br></pre></td></tr></table></figure><h2 id="建立终端和用户登录系统"><a class="header-anchor" href="#建立终端和用户登录系统"># </a>建立终端和用户登录系统</h2><h3 id="建立终端"><a class="header-anchor" href="#建立终端"># </a>建立终端</h3><p>  在启动过程中还有一个配置文件会生效，就是 /etc/init/start-ttys.conf，这个文件主要定义了 Linux 支持的 1~6 个本地终端（tty[1-6])。</p><p>  在inittab中的以下6行定义了6个终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1:2345:respawn:/sbin/mingetty tty1</span><br><span class="line">2:2345:respawn:/sbin/mingetty tty2</span><br><span class="line">3:2345:respawn:/sbin/mingetty tty3</span><br><span class="line">4:2345:respawn:/sbin/mingetty tty4</span><br><span class="line">5:2345:respawn:/sbin/mingetty tty5</span><br><span class="line">6:2345:respawn:/sbin/mingetty tty6</span><br></pre></td></tr></table></figure><p>  从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。</p><h3 id="用户登陆系统"><a class="header-anchor" href="#用户登陆系统"># </a>用户登陆系统</h3><p>一般来说，用户的登录方式有三种：</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录</li></ul><p>  对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。</p><p>  当通过mingetty登录时，Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数，然后对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。</p><h3 id="图形模式与文字模式的切换方式"><a class="header-anchor" href="#图形模式与文字模式的切换方式"># </a>图形模式与文字模式的切换方式</h3><p>  Linux预设提供了六个命令窗口终端机让我们来登录。</p><p>  默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。</p><p>  如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。</p><p>  如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1~F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6 切换至命令窗口。</p><hr><p>至此Linux启动完成，流程图如下</p><img src="/../assets/Linux/0/Linux启动过程.jpg" alt="Linux启动过程" style="zoom:125%;"><h2 id="linux-关机"><a class="header-anchor" href="#linux-关机"># </a>Linux 关机</h2><p>  在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>  正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt</p><p>  关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sync 将数据由内存同步到硬盘中。</span><br><span class="line"></span><br><span class="line">shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><span class="line"></span><br><span class="line">shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。</span><br><span class="line"></span><br><span class="line">shutdown –h now 立马关机</span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 系统会在今天20:25关机</span><br><span class="line"></span><br><span class="line">shutdown –h +10 十分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –r now 系统立马重启</span><br><span class="line"></span><br><span class="line">shutdown –r +10 系统十分钟后重启</span><br><span class="line"></span><br><span class="line">reboot 就是重启，等同于 shutdown –r now</span><br><span class="line"></span><br><span class="line">halt 关闭系统，等同于shutdown –h now 和 poweroff</span><br></pre></td></tr></table></figure><hr><p>  最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p><p>  关机的命令有 <strong>shutdown –h now halt poweroff</strong> 和 <strong>init 0</strong> , 重启系统的命令有 <strong>shutdown –r now reboot init 6</strong>。</p><blockquote><p><strong>参考文档地址：</strong></p><p><em>IBM Develope：<a href="https://www.ibm.com/developerworks/cn/linux/l-linuxboot/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-linuxboot/index.html</a></em></p><p><em>C语言中文网：<a href="http://c.biancheng.net/view/1014.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1014.html</a></em></p><p>菜鸟教程：<a href="https://www.runoob.com/linux/linux-system-boot.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-system-boot.html</a></p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>默认 Linux 硬件的驱动是不需要手工安装的，如果是重要的功能，则会直接编译到内核当中；如果是非重要的功能，比如硬件驱动会编译为模块，则在需要时由内核调用。不过，如果没有被内核硬件，要想驱动，就需要手工安装个硬件的硬块了。 <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 服务器端 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统启动过程详解</title>
      <link href="/note/server/linux/Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/note/server/linux/Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>  Linux系统的启动，从计算机开机通电自检开始，一直到登陆系统，总共经历如下几个过程：</p><ol><li>服务器加电，加载 BIOS 信息，BIOS 进行系统检测。依照 BIOS 设定，找到第一个可以启动的设备（一般是硬盘）；</li><li>读取第一个启动设备的 MBR (主引导记录），加载 MBR 中的 Boot Loader（启动引导程序，最为常见的是 GRUB）。</li><li>依据 Boot Loader 的设置加载内核，内核会再进行一遍系统检测。系统一般会采用内核检测硬件的信息，而不一定采用 Bios 的自检信息。内核在检测硬件的同时，还会通过加载动态模块的形式加载硬件的驱动。</li><li>内核启动系统的第一个进程，也就是 /sbin/init。</li><li>由 /sbin/init 进程调用/etc目录下的init程序 ，来配置计算机的初始环境、确定系统的默认运行级别。</li><li>确定默认运行级别后，调用 /etc/init/rc.conf 配置文件初始化系统，然后执行 /etc/rc.d/rc.local 中的程序。</li><li>如果是终端界面启动，就可以看到登录界面了。如果是图形界面启动，就会调用相应的 X Window 接口。</li></ol><a id="more"></a><hr><p>  总的来说Linux启动过程大致分为五个过程:<code>BIOS启动-&gt;内核引导过程-&gt;运行init(初始化配置文件)-&gt;系统初始化-&gt;建立终端或载入用户登陆系统</code></p><h2 id="硬件启动与引导"><a class="header-anchor" href="#硬件启动与引导"># </a>硬件启动与引导</h2><h3 id="biso启动"><a class="header-anchor" href="#biso启动"># </a>BISO启动</h3><p>  BIOS 全称 Basic Input/Output System，中文可译为基本输入/输出系统。它是固化在主板上一个 ROM（只读存储器）芯片上的程序，主要保存计算机的基本输入/输出信息、系统设置信息、开机自检程和系统自启动程序，用来为 计算机提供最底层和最直接的硬件设置与控制。BIOS 的初始化主要完成以下 几 项工作：</p><ol><li>当 BIOS 一启动，就会检查计算机硬件和外围设备（例如 CPU、内存、风扇灯），整个自检过程也被称为 POST（Power On Self Test）自检。</li><li>如果自检没有问题，BIOS 开始对硬件进行初始化，并规定当前可启动设备的先后顺序，选择由那个设备来开机。</li><li>选择好开启设备后，就会从该设备的 MBR（主引导目录）中读取 Boot Loader（启动引导程序）并执行。启动引导程序用于引导操作系统启动，Linux系统中默认使用的启动引导程序是 GRUB。</li><li>当 MBR 被加载到 RAM 之后，BIOS 就会将控制权交给 MBR，进入系统引导的第二阶段。</li></ol><h3 id="读取mbr"><a class="header-anchor" href="#读取mbr"># </a>读取MBR</h3><p>  MBR 也就是主引导记录，最主要的功能就是存储启动引导程序。MBR位于硬盘的 0 磁道、0 柱面、1 扇区中，主要记录了启动引导程序和磁盘的分区表。MBR 共占用了一个扇区，也就是 512 Byte。其中 446 Byte 安装了启动引导程序，其后 64 Byte 描述分区表，最后的 2 Byte 是结束标记。</p><blockquote><p>MBR结构图：</p></blockquote><p><img src="/../assets/Linux/0/MDR%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="MDR结构图"></p><p>  之所以每块硬盘只能划分四个分区，原因就是在 MBR 中描述分区表的空间只有 64 Byte。其中每个分区必须占用 16 Byte，那么 64 Byte 就只能划分 4 个主分区。每个分区的 16 字节的规划如表 ：</p><table><thead><tr><th style="text-align:center">存储字节</th><th style="text-align:center">数据内容及含义</th></tr></thead><tbody><tr><td style="text-align:center">第 1 字节</td><td style="text-align:center">引导标志</td></tr><tr><td style="text-align:center">第 2 字节</td><td style="text-align:center">本分区的起始磁道号</td></tr><tr><td style="text-align:center">第 3 字节</td><td style="text-align:center">本分区的起始扇区号</td></tr><tr><td style="text-align:center">第 4 字节</td><td style="text-align:center">本分区的起始柱面号</td></tr><tr><td style="text-align:center">第 5 字节</td><td style="text-align:center">分区类型，可以识别主分区和扩展分区</td></tr><tr><td style="text-align:center">第 6 字节</td><td style="text-align:center">本分区的结束磁道号</td></tr><tr><td style="text-align:center">第 7 字节</td><td style="text-align:center">本分区的结束扇区号</td></tr><tr><td style="text-align:center">第 8 字节</td><td style="text-align:center">本分区的结束柱面号</td></tr><tr><td style="text-align:center">第 9~12 字节</td><td style="text-align:center">本分区之前已经占用的扇区数</td></tr><tr><td style="text-align:center">第 13~16 字节</td><td style="text-align:center">本分区的总扇区数</td></tr></tbody></table><h4 id="启动引导程序的作用"><a class="header-anchor" href="#启动引导程序的作用"># </a>启动引导程序的作用</h4><p>  BIOS 的作用就是自检，然后从 MBR 中读取出启动引导程序，所以，启动引导程序最主要的作用就是加载操作系统的内核。由于每种操作系统的文件格式不同，因此每种操作系统的启动引导程序也不一样。不同的操作系统只有使用自己的启动引导程序才能加载自己的内核。如果服务器中安装了多个操作系统，而 MBR 只有一 个，那么明显是不够用的。</p><p>  然而每块硬盘只能有一个 MBR 是不能更改的，所以不可能増加 MBR 的数量。系统只能在每个文件系统（可以看成分区）中单独划分出一个扇区，称作引导扇区（Boot Sector)。每个分区的引导扇区中也能安装启动引导程序，也就是说，在 MBR 和每个单独分区的引导扇区中都可以安装启动引导程序。这样多个操作系统才能安装在同一台服务器中（每个操作系统要安装在不同的分区中），而且每个操作系统都是可以启动的。</p><p>  但是BIOS 只能找到 MBR 中的启动引导程序，而找不到在分区的引导扇区中的启动引导程序。如果要想完成多系统启动，那么就要増加启动引导程序的功能，让安装到 MBR 中的启动引导程序（GRUB）来调用在分区的引导扇区中的其他启动引导程序。</p><p>因此，启动引导程序拥有以下功能：</p><ol><li>加载操作系统的内核。这是启动引导程序最主要的功能。</li><li>拥有一个可以让用户选择的菜单，来选择到底启动哪个系统。大家如果在服务器上安装过双 Windows 系统，就应该见过类似的选择菜单，不过这个选择菜单是由 Windows 的启动引导程序提供的，而不是 GRUB。</li><li>可以调用其他的启动引导程序，这是多系统启动的关键。不过需要注意的是，Windows 的启动引导程序不能调用 Linux的启动引导程序，所以我们一般建议先安装 Windows，后安装 Linux，是为了将 Linux 的启动引导程序安装到 MBR 中，覆盖 Windows 的启动引导程序。</li></ol><p>启动引导程序的作用示意图：</p><img src="/../assets/Linux/0/MBR的作用.jpg" alt="MBR的作用" style="zoom:125%;"><h2 id="linux内核模块加载"><a class="header-anchor" href="#linux内核模块加载"># </a>Linux内核模块加载</h2><p>  GRUB 加载了内核之后，内核首先会再进行二次系统的自检，而不一定使用 BIOS 检测的硬件信息。这时内核终于开始替代 BIOS 接管 Linux的启动过程了。</p><p>  内核再次系统自检后，就会开始动态加载每个硬件的模块，这个动态模块大家可以想象成硬件的驱动<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。Linux 的内核存放在 /boot 的启动目录中。</p><figure class="highlight bash"><figcaption><span>/boot目录</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#ls /boot/</span></span><br><span class="line">config-2.6.32-279.el6.i686 <span class="comment">#内核的配置文件，内核编译时选择的功能与模块</span></span><br><span class="line">efi <span class="comment">#可扩展固件接口，为英特尔为全新PC固件的体系结构、接口和服务提出的建议标准</span></span><br><span class="line">grub <span class="comment">#启动引导程GTUB的数据目录</span></span><br><span class="line">initramfe-2.6.32-279.el6.i686.img <span class="comment">#虚拟文件系统（CentOS 6.x 中用initramfs替代了initrd,但功能是一样的）</span></span><br><span class="line">lost+found <span class="comment"># boot分区的备份目录</span></span><br><span class="line">symvers-2_6.32-279.el6.i686.gz <span class="comment">#模块符号信息</span></span><br><span class="line">System.map-2.6.32-279.el6.i686 <span class="comment">#内核功能和内存地址的对应列表</span></span><br><span class="line">vmlinuz-2.6.32-279.el6.i686 <span class="comment">#用于启动的Linux内核。这个文件是一个压缩的内核镜像</span></span><br></pre></td></tr></table></figure><p>  Linux 为了保证了内核不会过大，会把不重要的功能编译成内核模块，在需要时再调用。在多数 Linux 中，都会把硬件的驱动程序编译为模块， 这些模块保存在 /lib/modules 目录中。常见的 USB、SATA 和 SCSI 等硬盘设备的驱动，还有一些特殊的文件系统（如 LVM、RAID 等）的驱动，都是以模块的方式来保存的。</p><p>  如果 Linux 安装在 IDE 硬盘之上，并且采用的是默认的 ext3/4 文件系统，那么内核启动后加载根分区和模块的加载都没有什么问题。如果要将 Linux 安装在 SCSI 硬盘之上，或者采用的是 LVM 文件系统，那么内核（内核载入内存是启动引导程序 GRUB 调用的，并不存在硬盘驱动不识别的问题）在加载根目录之前是需要加载 SCSI 硬盘或 LVM 文件系统的驱动的。而SCSI 硬盘和 LVM 文件系统的驱动都放在硬盘的 /lib/modules 目录中，内核没有办法识别 ，因此Linux 采用了 initramfs 这个虚拟文件系统来处理这个问题。</p><h3 id="initramfe虚拟文件系统"><a class="header-anchor" href="#initramfe虚拟文件系统"># </a>initramfe虚拟文件系统</h3><p>  CentOS 6.x 中使用 initramfs 虚拟文件系统取代了 CentOS 5.x 中的 initrd RAM Disk。它们的作用类似，可以通过 initramfs 虚拟文件系统在内存中模拟出一个根目录，然后在这个模拟根目录中加载 SCSI 等硬件的驱动，就可以加载真正的根目录了，之后才能调用 Linux 的第一个进程 /sbin/init。</p><p>Initramfs 虚拟文件系统主要有以下优点：</p><ul><li>initramfs 随着其中数据的増减自动増减容量。</li><li>在 initramfs 和页面缓存之间没有重复数据。</li><li>initramfs 重复利用了 Linux caching 的代码，因此几乎没有増加内核尺寸，而 caching 的代码已经经过良好测试，所以 initramfs 的代码质量也有保证。</li><li>不需要额外的文件系统驱动</li></ul><img src="/../assets/Linux/0/initramfe虚拟文件系统.jpg" alt="initramfe虚拟文件系统" style="zoom:125%;"><hr><p>  内核启动后，首先会去解析grub的配置文件<code>/boot/grub/grub.conf</code>，然后加载内核镜像到内存中，并将控制权转交给内核。而内核会立即初始化系统中各设备并做相关的配置工作，其中包括CPU、I/O、存储设备等。在内核加载完毕，系统开始运行第一个进程。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/bg2013081702.png" alt="内核引导"></p><h2 id="第一个进程：init"><a class="header-anchor" href="#第一个进程：init"># </a>第一个进程：init</h2><p>  在内核加载完毕，并完成硬件检测与驱动程序加载后，此时主机硬件已经准备完毕，内核会主动呼叫第一个进程，也就是 /sbin/init，此配置文件最主要的功能就是准备软件执行的环境，包括系统的主机名、网络设定、语言、文件系统格式及其他服务的启动等。</p><p>  由于Linux内核的不断发展，各个发行版、各个版本的操作系统，采用的init程序配置系统完全不同。基本上是由 /sbin/init 进程来 <strong>配置计算机的初始环境</strong> 和 <strong>确定系统的默认运行级别</strong>。</p><p>  例如在 CentOS 6.x 系统中，由于用 Upstart 启动服务来替换以前的 init，所以在 /etc/inittab 配置文件中只能定义系统的默认运行级别，而其他的功能是靠 /etc/init/ 目录中的其他配置文件实现的。</p><blockquote><p>init程序的类型举例：</p><ul><li><p><strong>SysV:</strong> init, CentOS 5之前, 配置文件： <code>/etc/inittab。</code></p></li><li><p><strong>Upstart:</strong> init,CentOS 6, 配置文件：<code>/etc/inittab</code>,<code>/etc/init/*.conf。</code></p></li><li><p><strong>Systemd：</strong> systemd, CentOS 7,配置文件：<code>/usr/lib/systemd/system</code>、<code>/etc/systemd/system</code>。</p></li></ul><p>关于init系统的介绍，可以阅读以下文章：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html" target="_blank" rel="noopener">浅谈SysVinit</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/index.html" target="_blank" rel="noopener">浅谈Upstart</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html" target="_blank" rel="noopener">浅谈Systemd</a></li></ul></blockquote><h3 id="配置计算机的初始环境"><a class="header-anchor" href="#配置计算机的初始环境"># </a>配置计算机的初始环境</h3><p>  以centos 6采用的Upstart系统举例， /sbin/init 进程通过 /etc/init/rcS.conf 配置文件，分别找到 /etc/rc.d/rc.sysinit 配置文件和 /etc/inittab 配置文件，前者用于初始化系统，配置计算机的初始环境；后者用于确定系统的默认运行级别。用 Vim 查看 /etc/rc.d/rc.sysinit 配置文件，就会发现这个这个配置文件主要进行了以下几项工作：</p><ul><li>获得网络环境和主机类型；</li><li>测试设备：除了挂载内存设备 /proc 之外，还会主动侦测系统上是否具有 usb 设备，如果有，则会主动加载 usb 的驱动程序，并尝试挂载 usb 文件系统；</li><li>开机启动画面 Plymouth（代替了以往的 RHGB）；</li><li>判断是否启用 SELinux；</li><li>显示开机过程中的欢迎画面；</li><li>初始化硬件；</li><li>用户自定义模块的加载，用户可以在<code>/etc/sysconfig/modules/*.modules</code> 加入自订的模块，则此时会被加载到系统当中；</li><li>配置内核的参数，系统会主动去读取<code>/etc/sysctl.conf</code>这个文件的配置参数，使内核的功能成为我们想要的样子。</li><li>设置主机名。</li><li>同步存储器。</li><li>设备映射器及相关的初始化。</li><li>初始化软件磁盘阵列 (RAID)。</li><li>初始化 LVM 的文件系统功能。</li><li>检验磁盘文件系统 (fsck)。</li><li>设置磁盘配额 (quota)。</li><li>重新以可读写模式挂载系统磁盘。</li><li>更新 quota (非必要)。</li><li>启动系统虚拟随机数生成器。</li><li>配置机器（非必要）。</li><li>清除开机过程中的临时文件。</li><li>创建 ICE 目录。</li><li>启动交换分区（swap）。</li><li>将开机信息写入<code>/var/log/dmesg</code> 文件中。</li></ul><p>  <code>/etc/rc.d/rc.sysinit</code>配置文件已经将基本的系统配置数据都写好了，我们可以查询 <code>/var/log/dmesg</code>文件或使用 dmesg 命令查看系统在启动时到底发生了什么。当然，我们也可以通过这个命令来看看 Linux 服务器的硬件信息。</p><h3 id="配置运行级别"><a class="header-anchor" href="#配置运行级别"># </a>配置运行级别</h3><p>  在 CentOS 6.x 中，/etc/inittab 配置文件只能用来设置系统的默认运行级别。而在systemd 系统中，采用目标（target）替代了运行级别的概念，这里展示了Sysvinit 运行级别和 systemd 目标的对应表。</p><table><thead><tr><th style="text-align:center">Sysvinit 运行级别</th><th style="text-align:center">Systemd 目标</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">runlevel0.target, poweroff.target</td><td style="text-align:center">关闭系统。</td></tr><tr><td style="text-align:center">1, s, single</td><td style="text-align:center">runlevel1.target, rescue.target</td><td style="text-align:center">单用户模式。可以想象为 Windows 的安全模式，主要用于系统修复</td></tr><tr><td style="text-align:center">2, 4</td><td style="text-align:center">runlevel2.target, runlevel4.target, multi-user.target</td><td style="text-align:center">用户定义,不含 NFS 服务/域特定运行级别。默认等同于 3。</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">runlevel3.target, multi-user.target</td><td style="text-align:center">多用户，非图形化。用户可以通过多个控制台或网络登录。</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">runlevel5.target, graphical.target</td><td style="text-align:center">多用户，图形化。通常为所有运行级别 3 的服务外加图形化登录。</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">runlevel6.target, reboot.target</td><td style="text-align:center">重启</td></tr><tr><td style="text-align:center">emergency</td><td style="text-align:center">emergency.target</td><td style="text-align:center">紧急 Shell</td></tr></tbody></table><p>在 Linux 系统中可以使用 runlevel 命令来查看系统的运行级别，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># runlevel</span></span><br></pre></td></tr></table></figure><h2 id="系统初始化"><a class="header-anchor" href="#系统初始化"># </a>系统初始化</h2><p>  以centos6 为例子，在init的配置文件中有这么一行：<code>si::sysinit:/etc/rc.d/rc.sysinit</code>　它调用执行了<code>/etc/rc.d/rc.sysinit</code>，而rc.sysinit是一个bash shell的脚本，是每一个运行级别都要首先运行的重要脚本。在其中会有类似这样的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l5:5:<span class="built_in">wait</span>:/etc/rc.d/rc 5</span><br></pre></td></tr></table></figure><p>  其中数字5就是我们要运行的运行级别，这一行表示以5为参数运行<code>/etc/rc.d/rc</code>。<code>/etc/rc.d/rc</code>是一个Shell脚本，它接受5作为参数，去执行 <code>/etc/rc.d/rc5.d/</code>目录下的所有的rc启动脚本，<code>/etc/rc.d/rc5.d/</code>目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在<code>/etc/rc.d/init.d</code>/目录下。这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</p><p>  <code>/etc/rc.d/rc5.d/</code>中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以<code>/var/lock/subsys/</code>下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。</p><p>  在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&quot;System Services&quot;来自行设定。</p><h3 id="载入自定义配置"><a class="header-anchor" href="#载入自定义配置"># </a>载入自定义配置</h3><p>  在<code>/etc/rc.d/rc[0-6].d</code> 目录中的程序启动之后，系统的启动就已经完成。不过，我们总有一些程序是需要在系统启动之后随着系统一起启动的。这时我们并不需要自己把需要启动的服务链接到 /etc/rc3.d/ 目录中，因为系统给我们准备了 /etc/rc.d/rc.local 配置文件。</p><p>  这个配置文件会在用户登陆之前读取，这个文件中写入了什么命令，在每次系统启动时都会执行一次。也就是说，如果有任何需要在系统启动时运行的工作，则只需写入 /etc/rc.d/rc.local 配置文件即可。这个文件的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll /etc/rc.local</span><br><span class="line">Irwxrwxrwx. 1 root root 13 4月10 21:46 /etc/rc.local -&gt; rc.d/rc.local</span><br><span class="line">#有一个链接文件，两个文件修改哪一个都可以</span><br><span class="line">[root@localhost ~]#vi /etc/rc.d/rc.local</span><br><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line">#This script will be executed *after* all the other init scripts.</span><br><span class="line">#You can put your own initialization stuff in here if you don&apos;t</span><br><span class="line">#want to do the full Sys V style init stuff.</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">#默认会touch这个文件，每次系统启动时都会touch这个文件，这个文件的修改时间就是系统的启动时间</span><br><span class="line">/etc/rc.d/init.d/httpd start</span><br><span class="line">#如果写入RPM包安装的apache服务的启动命令，apache服务就会在开机时自动启动</span><br></pre></td></tr></table></figure><h2 id="建立终端和用户登录系统"><a class="header-anchor" href="#建立终端和用户登录系统"># </a>建立终端和用户登录系统</h2><h3 id="建立终端"><a class="header-anchor" href="#建立终端"># </a>建立终端</h3><p>  在启动过程中还有一个配置文件会生效，就是 /etc/init/start-ttys.conf，这个文件主要定义了 Linux 支持的 1~6 个本地终端（tty[1-6])。</p><p>  在inittab中的以下6行定义了6个终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1:2345:respawn:/sbin/mingetty tty1</span><br><span class="line">2:2345:respawn:/sbin/mingetty tty2</span><br><span class="line">3:2345:respawn:/sbin/mingetty tty3</span><br><span class="line">4:2345:respawn:/sbin/mingetty tty4</span><br><span class="line">5:2345:respawn:/sbin/mingetty tty5</span><br><span class="line">6:2345:respawn:/sbin/mingetty tty6</span><br></pre></td></tr></table></figure><p>  从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。</p><h3 id="用户登陆系统"><a class="header-anchor" href="#用户登陆系统"># </a>用户登陆系统</h3><p>一般来说，用户的登录方式有三种：</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录</li></ul><p>  对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。</p><p>  当通过mingetty登录时，Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数，然后对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。</p><h3 id="图形模式与文字模式的切换方式"><a class="header-anchor" href="#图形模式与文字模式的切换方式"># </a>图形模式与文字模式的切换方式</h3><p>  Linux预设提供了六个命令窗口终端机让我们来登录。</p><p>  默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。</p><p>  如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。</p><p>  如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1~F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6 切换至命令窗口。</p><h2 id="linux-关机"><a class="header-anchor" href="#linux-关机"># </a>Linux 关机</h2><p>  在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>  正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt</p><p>  关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sync 将数据由内存同步到硬盘中。</span><br><span class="line"></span><br><span class="line">shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><span class="line"></span><br><span class="line">shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。</span><br><span class="line"></span><br><span class="line">shutdown –h now 立马关机</span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 系统会在今天20:25关机</span><br><span class="line"></span><br><span class="line">shutdown –h +10 十分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –r now 系统立马重启</span><br><span class="line"></span><br><span class="line">shutdown –r +10 系统十分钟后重启</span><br><span class="line"></span><br><span class="line">reboot 就是重启，等同于 shutdown –r now</span><br><span class="line"></span><br><span class="line">halt 关闭系统，等同于shutdown –h now 和 poweroff</span><br></pre></td></tr></table></figure><hr><p>  最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p><p>  关机的命令有 <strong>shutdown –h now halt poweroff</strong> 和 <strong>init 0</strong> , 重启系统的命令有 <strong>shutdown –r now reboot init 6</strong>。</p><blockquote><p><strong>参考文档地址：</strong></p><p><em>IBM Develope：<a href="https://www.ibm.com/developerworks/cn/linux/l-linuxboot/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-linuxboot/index.html</a></em></p><p><em>C语言中文网：<a href="http://c.biancheng.net/view/1014.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1014.html</a></em></p><p>菜鸟教程：<a href="https://www.runoob.com/linux/linux-system-boot.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-system-boot.html</a></p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>默认 Linux 硬件的驱动是不需要手工安装的，如果是重要的功能，则会直接编译到内核当中；如果是非重要的功能，比如硬件驱动会编译为模块，则在需要时由内核调用。不过，如果没有被内核硬件，要想驱动，就需要手工安装个硬件的硬块了。 <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 服务器端 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6中的数据类型判断</title>
      <link href="/note/web/ecmascript/es6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
      <url>/note/web/ecmascript/es6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="es6中的数据类型判断的几种方式"><a class="header-anchor" href="#es6中的数据类型判断的几种方式"># </a>ES6中的数据类型判断的几种方式</h2><h3 id="1-typeof"><a class="header-anchor" href="#1-typeof"># </a>1.typeof</h3><p>typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型,返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：</p><ul><li>number、</li><li>boolean、</li><li>symbol、</li><li>string、</li><li>object、</li><li>undefined、</li><li>function 等。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">''</span>; <span class="comment">// string 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// number 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// symbol 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">//boolean 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">//undefined 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> [] ; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>(); <span class="comment">// function 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//object 无效</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>总结：</strong></p><ul><li>对于基本类型，除 null 以外，均可以返回正确的结果。</li><li>对于引用类型，除 function 以外，一律返回 object 类型。</li><li>对于 null ，返回 object 类型。</li><li>对于 function 返回 function 类型。</li></ul><h3 id="2-instanceof"><a class="header-anchor" href="#2-instanceof"># </a>2.instanceof</h3><ul><li>instanceof 检测的是原型对象。</li><li>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B。</li><li>如果 A 是 B 的实例，则返回 true,否则返回 false。</li><li>当 A 的 <strong>proto</strong> 指向 B 的 prototype 时，就认为 A 就是 B 的实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>;<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> Person;</span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Person <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>原型链举例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[].__proto__ --&gt; <span class="built_in">Array</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.__proto__ --&gt; <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ --&gt;<span class="literal">null</span></span><br></pre></td></tr></table></figure><p><strong>问题总结：</strong></p><ul><li>instanceof 只能用来判断两个对象是否属于实例关系，而不能判断一个对象实例具体属于哪种类型。</li><li>它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">xArray = <span class="built_in">window</span>.frames[<span class="number">0</span>].Array;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> xArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">   <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array.isArray() 本质上检测的是对象的 [[Class]] 值，[[Class]] 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 [object Xxx] ，Xxx 就是对应的具体类型 。对于数组而言，[[Class]] 的值就是 [object Array] 。</p><h3 id="3-constructor"><a class="header-anchor" href="#3-constructor"># </a>3.constructor</h3><ul><li>当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用</li><li>当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor == F</li><li>F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</li></ul><p><strong>注意：</strong></p><ul><li>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</li><li>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</li></ul><h3 id="4-tostring"><a class="header-anchor" href="#4-tostring"># </a>4.toString</h3><ul><li>toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</li><li>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) ;   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ; <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ; <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) ; <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) ; <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) ; <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ; <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ; <span class="comment">//[object global] window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a class="header-anchor" href="#总结"># </a>总结</h2><p><strong>typeof：</strong></p><ul><li>可判断<ul><li>数值</li><li>字符串</li><li>布尔值</li><li>undefined</li><li>function</li></ul></li><li>不可判断<ul><li>null</li><li>object</li><li>array</li></ul></li></ul><p><strong>instance：</strong></p><ul><li>判断对象具体类型</li></ul><p><strong>全等于：</strong></p><ul><li>null/undefined</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> EcmaScript </category>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> EcmaScript </tag>
            
            <tag> ES6 </tag>
            
            <tag> 类型判断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo—Next自定义修改日志</title>
      <link href="/log/"/>
      <url>/log/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>本文用于记录本站每次更新的详情</p></blockquote><h2 id="2019-11-19-第一次修改"><a class="header-anchor" href="#2019-11-19-第一次修改"># </a>2019/11/19 第一次修改</h2><p>博客引用了hexo的next主题，主题github地址为<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a>,按照<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">官方文档</a>的介绍精心了初步配置</p><h3 id="把hexo项目同步到git中存储"><a class="header-anchor" href="#把hexo项目同步到git中存储"># </a>把hexo项目同步到git中存储</h3><p>为了将将项目文档同步到git中，保护自己在配置中的各类网站的key，按照官方的建议，把主题配置的_config.yml内容拷贝到了 /source/_data/next.yml中，上传到了自己的私有git仓库中</p><a id="more"></a><h3 id="目录结构的修改"><a class="header-anchor" href="#目录结构的修改"># </a>目录结构的修改</h3><p>方便以后查阅自己的笔记总结，新建了一个page笔记页面，并自定义了笔记目录，由与内容比较多就，接下来会逐步更新</p><h3 id="对next主题的自定义修改"><a class="header-anchor" href="#对next主题的自定义修改"># </a>对Next主题的自定义修改</h3><h4 id="在页尾添加自定义的图文footer-banner"><a class="header-anchor" href="#在页尾添加自定义的图文footer-banner"># </a>在页尾添加自定义的图文footer-banner</h4><p>在查阅官方的Muse主题的案例推荐后，看到<a href="https://leaferx.online/" target="_blank" rel="noopener">leaferx</a>文档下有一个自定义的图片banner比较有范，于是查阅了博主的样式设置，由于对swig语法还不太熟悉，就简单粗暴的修改了原始模版，具体方法如下</p><p>在next主题的 _layout/_layout.swfg 的footer标签，footer-inner class 上添加如下标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.custom-banner</span>&#123;</span></span><br><span class="line">    background-attachment: fixed;</span><br><span class="line">    background-position: center bottom;</span><br><span class="line">    padding: 40px 0;</span><br><span class="line">    margin-bottom: 40px;</span><br><span class="line">    background-size: 100%;</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>);</span></span><br><span class="line">    background-image: url(/images/sea.jpg);</span><br><span class="line">    background-blend-mode: darken;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.custom-banner</span> <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line">    text-align: center;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    font-family: fira code,consolas,Menlo,pingfang sc,microsoft yahei,monospace;</span><br><span class="line">    font-style: italic;</span><br><span class="line">    font-weight: 400;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"custom-banner"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Stay hungary,Stay foolish.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="引入iconfont"><a class="header-anchor" href="#引入iconfont"># </a>引入iconfont</h4><p>由于Next主题使用的fontawsome免费的icon数量不是很多，而且版本比较老旧，因此使用iconfont的图标来丰富博客的图标库，网站链接在此<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></p><p><strong>修改方法：</strong></p><p>为了方便日后直接使用，在next主题的 _layout/_layout.swfg 的头部文件中的&lt;head&gt;便签末尾插入以下<code>html</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在iconfont生成项目后，每次添加不同的icon都会改变src地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//at.alicdn.com/t/font_1078070_hs0wiix70l.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.icon</span> &#123;</span></span><br><span class="line">    width: 1em; height: 1em;</span><br><span class="line"><span class="css">    <span class="selector-tag">vertical-align</span>: <span class="selector-tag">-0</span><span class="selector-class">.15em</span>;</span></span><br><span class="line">    fill: currentColor;</span><br><span class="line">    overflow: hidden;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>随后在需要使用的markdown文档中使用以下标签可以使用iconfont图标,href的内容为iconfont项目内的图标标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#icon-php"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><h4 id="将站点地图放置到页脚"><a class="header-anchor" href="#将站点地图放置到页脚"># </a>将站点地图放置到页脚</h4><p>站点地图是为了方便搜索引擎爬去信息，在layout/_partials/footer.swig中，将以下html添加到span.author标签下方</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-map"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>站点地图:<span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/sitemap.xml"</span> <span class="attr">style</span>=<span class="string">"color:#999"</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span>/</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/baidusitemap.xml"</span> <span class="attr">style</span>=<span class="string">"color:#999"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
          <category> Blog设置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> Nexo </tag>
            
            <tag> Next </tag>
            
            <tag> 主题 </tag>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start"><a class="header-anchor" href="#quick-start"># </a>Quick Start</h2><a id="more"></a><h3 id="create-a-new-post"><a class="header-anchor" href="#create-a-new-post"># </a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><a class="header-anchor" href="#run-server"># </a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="header-anchor" href="#generate-static-files"># </a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="header-anchor" href="#deploy-to-remote-sites"># </a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
